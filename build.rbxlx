<roblox version="4">
  <Item class="ReplicatedStorage" referent="0">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="MeshPart" referent="1">
      <Properties>
        <string name="Name">Egg</string>
      </Properties>
      <Item class="Script" referent="2">
        <Properties>
          <string name="Name">AutoHatch</string>
          <string name="Source">local UIService = require(game.ReplicatedStorage.PublicDependancies.UIService)
local chaoModule = require(game.ReplicatedStorage.PublicDependancies.ChaoModule)
local wait = task.wait

while wait(1) do
	if script.Parent.Held.Value == false then
		if script.Parent.HatchTime.Value &lt;= 0 then
			chaoModule.Hatch(script.Parent)
		else
			script.Parent.HatchTime.Value -= 1
		end
	end
end</string>
        </Properties>
      </Item>
      <Item class="Script" referent="3">
        <Properties>
          <string name="Name">Killvelocity</string>
          <string name="Source"><![CDATA[ script.Parent.Touched:Connect(function(hit)
	if hit.Parent.Name == "Wall" then
		script.Parent.Velocity *= 0
	end
end)]]></string>
        </Properties>
      </Item>
      <Item class="Script" referent="4">
        <Properties>
          <string name="Name">PickScript</string>
          <string name="Source"><![CDATA[--Makes it so you can pick up the egg and throw it
local wait = task.wait
--dependancies
local UIService = require(game.ReplicatedStorage.PublicDependancies.UIService)
UIService:GenerateContextMenu("Pick",script.Parent,Enum.KeyCode.E,Enum.KeyCode.ButtonX,"Pick up your chao.")
UIService:UpdateContextMenu(script.Parent.Pick,"Name","Pickup")

while wait(1) do
	local pickupStatus = UIService:GetContextMenuProperty(script.Parent.Pickup,"Context")
	if script.Parent.Held.Value == false then
		if pickupStatus ~= "Pick" then
			UIService:UpdateContextMenu(script.Parent.Pickup,"Context","Pick")
			UIService:UpdateContextMenu(script.Parent.Pickup,"ObjectText","Pick up your chao.")
		end
	else
		if script.Parent.Parent:FindFirstChild("HumanoidRootPart") then
			local velo = script.Parent.Parent.HumanoidRootPart.Velocity.Magnitude
			print("Velo")
			if velo >= 2 then
				if pickupStatus ~= "Throw" then
					UIService:UpdateContextMenu(script.Parent.Pickup,"Context","Throw")
					UIService:UpdateContextMenu(script.Parent.Pickup,"ObjectText","Throw your chao.")				
				end
			else
				if pickupStatus ~= "Drop" then
					UIService:UpdateContextMenu(script.Parent.Pickup,"Context","Drop")
					UIService:UpdateContextMenu(script.Parent.Pickup,"ObjectText","Place your chao down.")				
				end
			end
		end
	end
end

]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="5">
      <Properties>
        <string name="Name">MarketPlace</string>
      </Properties>
      <Item class="ModuleScript" referent="6">
        <Properties>
          <string name="Name">Class</string>
          <string name="Source">local tree = {
    Chao = {
        Name = "Chao",
        WoolHat = {
            Name = "Wool Hat",
            Desc = "A warm hat for your chao.",
            isDecor = true,
            Value = "1000",
        }
    },
    Food = {
        Name = "Food",
        Fruit = {
            Name = "Garden Fruit",
            Desc = "A regular fruit.",
            isDecor = false,
            Value = "50",
        },
        SFruit = {
            Name = "Square Fruit",
            Desc = "A square shaped fruit. Some chao love this.",
            isDecor = false,
            Value = "100"
        },
        RFruit = {
            Name = "Round Fruit",
            Desc = "A round shaped fruit. Some chao love this.",
            isDecor = false,
            Value = "125"
        },
        TFruit = {
            Name = "Triangle Fruit",
            Desc = "A triangle shaped fruit. Some chao love this.",
            isDecor = false,
            Value = "150"
        },
        StFruit = {
            Name = "Strong Fruit",
            Desc = "Help your chao grow stronger. (Power +4)",
            isDecor = false,
            Value = "200",
        },
        TaFruit = {
            Name = "Tasty Fruit",
            Desc = "A tasty fruit that all chao love. Its great for their health too.",
            isDecor = false,
            Value = "350",
        },
        HFruit = {
            Name = "Heart Fruit",
            Desc = "A sweet tasting fruit that gets chao ready to mate.",
            isDecor = false,
            Value = "500",
        },
        SMFruit = {
            Name = "Smart Fruit",
            Desc = "A fruit with riveting flavor that helps your chao learn.",
            isDecor = false,
            Value = "500",
        },
        Mint = {
            Name = "Mint Candy",
            Desc = "A lucky piece of candy sure to give your chao tons of energy. (Luck +25)",
            isDecor = false,
            Value = "800"
        }
    },
    Toys = {
        Name = "Toys",
        Car = {
            Name = "Toy Car",
            Desc = "A Toy Car that can be won from Chao Races",
            isDecor = false,
            Value = "-1000"
        }
    },
    Animals = {
        Name = "Animal",
        Wisps = {
            Name = "Wisps",
            White = {
                Name = "White Wisp",
                Desc = "The White Wisp. Helps make your chao faster. (Running +3)",
                isDecor = false,
                Value = "250"
            },
            Red = {
                Name = "Red Wisp",
                Desc = "The Red Wisp. Helps make your chao stronger. (Power +3)",
                isDecor = false,
                Value = "250"
            },
            Cyan = {
                Name = "Cyan Wisp",
                Desc = "The Cyan Wisp. Helps your chao swim better. (Swim +3)",
                isDecor = false,
                Value = "250"
            },
            Green = {
                Name = "Green Hover",
                Desc = "The Green",
                isDecor = false,
                Value = "250"
            }
        },
        Animals = {
            Name = "Animals",
            Gorrilla = {
                Name = "Monke",
                Desc = "The Gorrilla Animal. Found thoughout stages. Helps make your chao stronger at the cost of its flying skill. (Power +7) (Flying -3)",
                isDecor = false,
                Value = "250"
            }
        },
        ChaoDrives = {
            Name = "ChaoDrive",
            Run = {
                Name = "RunDrive",
                Desc = "The run chao drive. Increases your chao's running skill. Effectiveness depends on Chao's rank in running.",
                isDecor = false,
                Value = "-1"
            },
            Fly = {
                Name = "FlyDrive",
                Desc = "The fly chao drive. Increases your chao's flying skill. Effectiveness depends on Chao's rank in flying.",
                isDecor = false,
                Value = "-1"
            },
            Swim = {
                Name = "SwimDrive",
                Desc = "The swim chao drive. Increases your chao's swimming skill. Effectiveness depends on Chao's rank in swimming.",
                isDecor = false,
                Value = "-1"
            },
            Power = {
                Name = "PowerDrive",
                Desc = "The power chao drive. Increases your chao's power skill. Effectiveness depends on Chao's rank in power.",
                isDecor = false,
                Value = "-1"
            },
        },
    },
    Medals = {
        Name = "Medals"
    }
}

return tree</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="7">
        <Properties>
          <string name="Name">MarketData</string>
          <string name="Source">market = {
	Fruit = {
		Name = "Chao Fruit",
		isDecor = false,
		Price = "100",
		forSale = true,
		desc = "A tasty fruit all chao know and love,",
	}
}

return market</string>
        </Properties>
      </Item>
      <Item class="Folder" referent="8">
        <Properties>
          <string name="Name">rawItems</string>
        </Properties>
        <Item class="Model" referent="9">
          <Properties>
            <string name="Name">FlyDrive</string>
          </Properties>
          <Item class="Folder" referent="10">
            <Properties>
              <string name="Name">Meshes</string>
            </Properties>
            <Item class="MeshPart" referent="11">
              <Properties>
                <string name="Name">Cone</string>
              </Properties>
              <Item class="Script" referent="12">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="13">
              <Properties>
                <string name="Name">Cylinder (15)</string>
              </Properties>
              <Item class="Script" referent="14">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="15">
              <Properties>
                <string name="Name">Cylinder.001 (7)</string>
              </Properties>
              <Item class="Script" referent="16">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Script" referent="17">
            <Properties>
              <string name="Name">PickScript</string>
              <string name="Source"><![CDATA[--Makes it so you can feed your chao Chao Drives
local wait = task.wait
--dependancies
local UIService = require(game.ReplicatedStorage.PublicDependancies.UIService)
UIService:GenerateContextMenu("Pick",script.Parent,Enum.KeyCode.E,Enum.KeyCode.ButtonX,"Pick up your chao.")
UIService.updateContextMenu(script.Parent.Pick,"Name","ChaoDrive")

while wait(1) do
	local pickupStatus = UIService:GetContextMenuProperty(script.Parent.Pickup,"Context")
	if script.Parent.Held.Value == false then
		if pickupStatus ~= "Pick" then
			UIService.updateContextMenu(script.Parent.Pickup,"Context","Pick")
			UIService.updateContextMenu(script.Parent.Pickup,"ObjectText","Pick up the chaos drive.")
		end
	else
		if script.Parent.Parent:FindFirstChild("HumanoidRootPart") then
			if pickupStatus ~= "Drop" then
				UIService.updateContextMenu(script.Parent.Pickup,"Context","Drop")
				UIService.updateContextMenu(script.Parent.Pickup,"ObjectText","Place the chaos drive down.")				
			end
		end
	end
end

]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="Model" referent="18">
          <Properties>
            <string name="Name">PowerDrive</string>
          </Properties>
          <Item class="Folder" referent="19">
            <Properties>
              <string name="Name">Meshes</string>
            </Properties>
            <Item class="MeshPart" referent="20">
              <Properties>
                <string name="Name">Cone</string>
              </Properties>
              <Item class="Script" referent="21">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="22">
              <Properties>
                <string name="Name">Cylinder (15)</string>
              </Properties>
              <Item class="Script" referent="23">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="24">
              <Properties>
                <string name="Name">Cylinder.001 (7)</string>
              </Properties>
              <Item class="Script" referent="25">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Script" referent="26">
            <Properties>
              <string name="Name">PickScript</string>
              <string name="Source">--Makes it so you can feed your chao Chao Drives
local wait = task.wait
--dependancies
local UIService = require(game.ReplicatedStorage.PublicDependancies.UIService)
UIService:GenerateContextMenu("Pick",script.Parent,Enum.KeyCode.E,Enum.KeyCode.ButtonX,"Pick up your chao.")
UIService.updateContextMenu(script.Parent.Pick,"Name","ChaoDrive")

while wait(1) do
	local pickupStatus = UIService:GetContextMenuProperty(script.Parent.Pickup,"Context")
	if script.Parent.Held.Value == false then
		if pickupStatus ~= "Pick" then
			UIService.updateContextMenu(script.Parent.Pickup,"Context","Pick")
			UIService.updateContextMenu(script.Parent.Pickup,"ObjectText","Pick up the chaos drive.")
		end
	else
		if script.Parent.Parent:FindFirstChild("HumanoidRootPart") then
			if pickupStatus ~= "Drop" then
				UIService.updateContextMenu(script.Parent.Pickup,"Context","Drop")
				UIService.updateContextMenu(script.Parent.Pickup,"ObjectText","Place the chaos drive down.")				
			end
		end
	end
end</string>
            </Properties>
          </Item>
        </Item>
        <Item class="Model" referent="27">
          <Properties>
            <string name="Name">RunDrive</string>
          </Properties>
          <Item class="Folder" referent="28">
            <Properties>
              <string name="Name">Meshes</string>
            </Properties>
            <Item class="MeshPart" referent="29">
              <Properties>
                <string name="Name">Cone</string>
              </Properties>
              <Item class="Script" referent="30">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="31">
              <Properties>
                <string name="Name">Cylinder (15)</string>
              </Properties>
              <Item class="Script" referent="32">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="33">
              <Properties>
                <string name="Name">Cylinder.001 (7)</string>
              </Properties>
              <Item class="Script" referent="34">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Script" referent="35">
            <Properties>
              <string name="Name">PickScript</string>
              <string name="Source">--Makes it so you can feed your chao Chao Drives
local wait = task.wait
--dependancies
local UIService = require(game.ReplicatedStorage.PublicDependancies.UIService)
UIService:GenerateContextMenu("Pick",script.Parent,Enum.KeyCode.E,Enum.KeyCode.ButtonX,"Pick up your chao.")
UIService.updateContextMenu(script.Parent.Pick,"Name","ChaoDrive")

while wait(1) do
	local pickupStatus = UIService:GetContextMenuProperty(script.Parent.Pickup,"Context")
	if script.Parent.Held.Value == false then
		if pickupStatus ~= "Pick" then
			UIService.updateContextMenu(script.Parent.Pickup,"Context","Pick")
			UIService.updateContextMenu(script.Parent.Pickup,"ObjectText","Pick up the chaos drive.")
		end
	else
		if script.Parent.Parent:FindFirstChild("HumanoidRootPart") then
			if pickupStatus ~= "Drop" then
				UIService.updateContextMenu(script.Parent.Pickup,"Context","Drop")
				UIService.updateContextMenu(script.Parent.Pickup,"ObjectText","Place the chaos drive down.")				
			end
		end
	end
end</string>
            </Properties>
          </Item>
        </Item>
        <Item class="Model" referent="36">
          <Properties>
            <string name="Name">SwimDrive</string>
          </Properties>
          <Item class="Folder" referent="37">
            <Properties>
              <string name="Name">Meshes</string>
            </Properties>
            <Item class="MeshPart" referent="38">
              <Properties>
                <string name="Name">Cone</string>
              </Properties>
              <Item class="Script" referent="39">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="40">
              <Properties>
                <string name="Name">Cylinder (15)</string>
              </Properties>
              <Item class="Script" referent="41">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="42">
              <Properties>
                <string name="Name">Cylinder.001 (7)</string>
              </Properties>
              <Item class="Script" referent="43">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Script" referent="44">
            <Properties>
              <string name="Name">PickScript</string>
              <string name="Source">--Makes it so you can feed your chao Chao Drives
local wait = task.wait
--dependancies
local UIService = require(game.ReplicatedStorage.PublicDependancies.UIService)
UIService:GenerateContextMenu("Pick",script.Parent,Enum.KeyCode.E,Enum.KeyCode.ButtonX,"Pick up your chao.")
UIService.updateContextMenu(script.Parent.Pick,"Name","ChaoDrive")

while wait(1) do
	local pickupStatus = UIService:GetContextMenuProperty(script.Parent.Pickup,"Context")
	if script.Parent.Held.Value == false then
		if pickupStatus ~= "Pick" then
			UIService.updateContextMenu(script.Parent.Pickup,"Context","Pick")
			UIService.updateContextMenu(script.Parent.Pickup,"ObjectText","Pick up the chaos drive.")
		end
	else
		if script.Parent.Parent:FindFirstChild("HumanoidRootPart") then
			if pickupStatus ~= "Drop" then
				UIService.updateContextMenu(script.Parent.Pickup,"Context","Drop")
				UIService.updateContextMenu(script.Parent.Pickup,"ObjectText","Place the chaos drive down.")				
			end
		end
	end
end</string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
    <Item class="Folder" referent="45">
      <Properties>
        <string name="Name">PublicDependancies</string>
      </Properties>
      <Item class="ModuleScript" referent="46">
        <Properties>
          <string name="Name">ChaoModule</string>
          <string name="Source">print("Alive!")
math.randomseed(tick())

local repl = game.ReplicatedStorage
local visualService = require(script.Parent.VisualService)
local Datastore = game:GetService("DataStoreService")
local saveData = Datastore:GetDataStore("Sonic Earth Chao Garden Alpha")
local module = {}

--Moved out of the createChao function since we need this in the rebirth.
local personalityTable = {
	--Adding more in the future.
	"Gentle",
	"Naughty",
	"Energetic",
	"Quiet",
	"Big Eater",
	"Chatty",
	"Easily Bored",
	"Curious",
	"Carefree",
	"Careless",
	"Smart",
	"Cry Baby",
	"Lonely",
	"Naive"
}

function module.chaoDataexport()
	--Format the save data to a file that can be transered throughtout games using HTTPservice. I'll work on this later on.
	print("Ready.")
end

function module.changeData(stat,value,chaoData)
	if chaoData then
		if stat and value then
			local data = chaoData:FindFirstChild(stat)
			if data then
				local isNumber = tonumber(value)
				if isNumber then
					chaoData[stat].Value += value
				else 
					chaoData[stat].Value = value
				end
			else
				warn("Data doesn't exist")
			end
		end
	else
		warn("Invalid ChaoData")
	end
end

function module.changeStat(stat,value,chaoData)
	if chaoData then
		if stat and value then
			if stat == "Run" then
				local mx = chaoData.RunRank.Value
				local trueValue = value*mx
				chaoData.RunXP.Value += trueValue
				if chaoData.RunXP.Value >= chaoData.RunLevel.Value * 100 and chaoData.RunLevel.Value ~= 99 then
					chaoData.RunLevel.Value += 1
				end
			end
			if stat == "Power" then
				local mx = chaoData.PowerRank.Value
				local trueValue = value*mx
				chaoData.PowerXP.Value += trueValue
				if chaoData.PowerXP.Value >= chaoData.PowerLevel.Value * 100 and chaoData.PowerLevel.Value ~= 99 then
					chaoData.PowerLevel.Value += 1
				end
			end
			if stat == "Swim" then
				local mx = chaoData.SwimRank.Value
				local trueValue = value*mx
				chaoData.SwimXP.Value += trueValue
				if chaoData.SwimXP.Value >= chaoData.SwimLevel.Value * 100 and chaoData.SwimLevel.Value ~= 99 then
					chaoData.SwimLevel.Value += 1
				end
			end
			if stat == "Fly" then
				local mx = chaoData.FlyRank.Value
				local trueValue = value*mx
				chaoData.FlyXP.Value += trueValue
				if chaoData.FlyXP.Value >= chaoData.FlyLevel.Value * 100 and chaoData.FlyLevel.Value ~= 99 then
					chaoData.FlyLevel.Value += 1
				end
			end
			if stat == "Stamina" then
				local mx = chaoData.StaminaRank.Value
				local trueValue = value*mx
				chaoData.StaminaXP.Value += trueValue
				if chaoData.StaminaXP.Value >= chaoData.StaminaLevel.Value * 100 and chaoData.StaminaLevel.Value ~= 99 then
					chaoData.StaminaLevel.Value += 1
				end
			end
		end
	else
		warn("Invalid ChaoData")
	end
end

function module.newChao()
	print("Ready!")
	--generate stats
	local folder = game.ReplicatedStorage.Folder
	local rng = math.random(5)
	local statTable = {
		1,
		1,
		1,
		1,
		1
	}
	--fills the stats table and makes it so only one stat can be an A. This isn't for the genepool.
	local hasfive = false
	for i,v in pairs(statTable) do
		if not hasfive then
			local rng = math.random(5)
			statTable[i] = rng
			if rng == 5 then
				hasfive = true
			end
		else
			statTable[i] = math.random(4)
		end
	end
	folder.SwimRank.Value = statTable[1]
	folder.FlyRank.Value = statTable[2]
	folder.RunRank.Value = statTable[3]
	folder.PowerRank.Value = statTable[4]
	folder.StaminaRank.Value = statTable[5]
	folder.Age.Value = 0
	folder.Class.Value = 0
	folder.Attribute.Value = "Child"
	folder.Condition.Value = "none"
	folder.Happiness.Value = 50
	folder.Hunger.Value = 1
	local trng = math.random(#personalityTable)
	folder.Personality.Value = personalityTable[trng]
	--Here we randomize the position of the chao. I'll do that later on
	folder.Hatched.Value = false
	print("Done. New Chao Data made.")
	return folder
end

function module.spawnChao(chao) --chaoData
	if chao.Hatched.Value == true then
		--spawn a chao
		local copy = repl.baseChao:Clone()
		copy.Parent = workspace
		copy.HumanoidRootPart.Position = Vector3.new(10,0,10) --TODO: Randomize this
	else
		--spawn a chao egg
		local copy = repl.Egg:Clone()
		copy.Parent = workspace
		copy.Position = Vector3.new(170.047, 171.708, 256.577) --TODO: Randomize this
	end
end

function module.Hatch(Egg)
	if Egg then
		local hatchedEgg = repl.Broken_Egg:Clone()
		local goalPos = Egg.Position
		print(tostring(goalPos))
		hatchedEgg.Parent = workspace
		hatchedEgg:MoveTo(goalPos)
		Egg:Destroy()
		wait(3)
		local copy = repl.baseChao:Clone()
		copy.Parent = workspace
		copy.HumanoidRootPart.Position = goalPos
	else
		warn("No Egg to Hatch!")
	end
end

function module:GetStats(ChaoData,player, stat)
	if player and stat then
		if player:FindFirstChild(ChaoData) then
			if player.ChaoData[ChaoData]:FindFirstChild(stat) then
				return player.ChaoData[ChaoData][stat].Value
			end
		end
	end
end

function module:Evo(chaoData,chao,player)
	if player and chao then
		--Prevent the chao from Aging while evolving
		chaoData.canAge = false
		--Change ChaoState to sitting and play anim

		--Create Chao Cocoon
		local cocoon --Path to chao cocoon.
		cocoon:Clone()
		coccon.Parent = workspace
		cocoon.Position  = chao.HumanoidRootPart.Position

		--Determine Ability Evolution
		local chaoType
		if chaoData.AbilityDirection.Value >= 0.5 then
			chaoType = "Hero"
		elseif chaoData.AbilityDirection.Value &lt;= -0.5 then
			chaoType = "Dark"
		else
			chaoType = "Normal"
		end 
		--Apply Visual Changes
		visualService:ChangeHeadType(chao,chaoType)
		--Apply SaveData Changes
		chaoData.Ability.Value = chaoType
		--Determine Type Evolution
		if chaoData.LastUpgraded == "Swim" then
			chaoType = "Swim"
		elseif chaoData.LastUpgraded == "Fly" then
			chaoType = "Fly"
		elseif chaoData.LastUpgraded == "Run" then
			chaoType = "Run"
		elseif chaoData.LastUpgraded == "Power" then
			chaoType = "Power"
		end
		--Apply Visual Changes
		visualService:ChangeChaoType(chao,chaoType)
		--Apply SaveData Changes
		chaoData.Attribute.Value = chaoType
		--Remove Cocoon
		for count = 1,100 do
			cocoon.Transparency -= 0.01
		end
		cocoon:Destroy()
		--Clean up
		chaoData.canAge = true
	end
end

function module:Rebirth(chaoData,chao,player)
	if player and chao then
		--Prevent the chao from Aging while evolving
		chaoData.canAge = false
		--Change ChaoState to sitting and play anim

		--Create Pink Cocoon
		local cocoon --Path to chao cocoon.
		cocoon:Clone()
		coccon.Parent = workspace
		cocoon.Position  = chao.HumanoidRootPart.Position
		--Reset every stat to 10 percent of its current value
		chaoData.FlyXP.Value = math.floor(chaoData.FlyXP.Value*10/100)
		chaoData.SwimXP.Value = math.floor(chaoData.SwimXP.Value*10/100)
		chaoData.RunXP.Value = math.floor(chaoData.RunXP.Value*10/100)
		chaoData.PowerXP.Value = math.floor(chaoData.PowerXP.Value*10/100)
		chaoData.StaminaXP.Value = math.floor(chaoData.StaminaXP.Value*10/100)
		--Reset personaility
		local prng = math.random(#personalityTable)
		chaoData.Personality.Value = personalityTable[prng]
		--Reset Age
		chaoData.Age.Value = 0
		--Reset attribute and ablility
		chaoData.Attribute.Value = "Child"
		chaoData.AbilityDirection = 0
		chaoData.Ability.Value = ""
		--Remove Cocoon
		for count = 1,100 do
			cocoon.Transparency -= 0.01
		end
		cocoon:Destroy()
		--Clean up
		chaoData.canAge = true
	end
end

function module:RemoveChao(chaoData,chao,player)
	if chaoData and chao then
		--Prevent the chao from Aging while evolving
		chaoData.canAge = false
		--Change ChaoState to sitting and play anim

		--Create White Cocoon
		local cocoon --Path to chao cocoon.
		cocoon:Clone()
		coccon.Parent = workspace
		cocoon.Position  = chao.HumanoidRootPart.Position
		--Destroy ChaoData
		local wasInterupted = false
		for i,v in pairs(chaoData:GetChildren()) do
			local success, response = pcall(function(v)
				local save_data = saveData:GetAsync("User_"..player.UserId)
				save_data.Data[v] = nil
				saveData:SetAsync("User_"..player.UserId,save_data)
			end)
			if not success then
				print(response)
				wasInterupted = true
				break
			else end
		end
		--destroy the folder itself
		if wasInterupted == false then --ensure the data actually got deleted
			chaoData:Destroy()
		end
		--remove chao
		chao:Destroy()
		--Remove Cocoon
		for count = 1,100 do
			cocoon.Transparency -= 0.01
		end
		cocoon:Destroy()
	end
end

return module</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="47">
        <Properties>
          <string name="Name">ClassService</string>
          <string name="Source">local service = {}

local items = require(game.ReplicatedStorage.MarketPlace.Class)
local rawItems = game.ReplicatedStorage.MarketPlace.rawItems

function service.GetArrayItem(array,item)
    for i,v in pairs(array) do
        if v.Name == item then
            return v
        else end
    return false
    end
end

--Clone and object and return it
function service:GetItem(item)
    local itemExist = service.GetArrayItem(items,item)
    if itemExist then
        if rawItems:FindFirstChild(item) then
            local myItem = rawItems[item]:Clone()
            return myItem
        end
    else
        return nil
    end
end

--Return the description of an item
function service:GetItemInfo(class,item)
    local classExist = service.GetArrayItem(items,class)
    if classExist then
        local itemExist = service.GetArrayItem(items[class],item)
        if itemExist then
            return items[class][item].Desc
        else
            return nil
        end
    else
        return "Invalid Class"
    end
end

--Return all members of a class
function service:GetChildrenOfClass(class)
    local classExist = service.GetArrayItem(items,class)
    if classExist then
        return items[class]
    else
        return "Invalid Class"
    end
end

--Return an items stats (such as isDecor)
function service:GetItemDetails(class,item)
    local classExist = service.GetArrayItem(items,class)
    if classExist then
        local itemExist = service.GetArrayItem(items[class],item)
        if itemExist then
            return items[class][item]
        end
    else
        return "Invalid Class"
    end
end

--Returns the class an item belongs to.
function service:GetItemsClass(item)
    local class
    if service.GetArrayItem(items.Chao,item) then
        class = "Chao"
    elseif service.GetArrayItem(items.Food,item) then
        class = "Food"
    elseif service.GetArrayItem(items.Animals,item) then
        class = "Animals"
    elseif service.GetArrayItem(items.Toys) then
        class = "Toys"
    elseif service.GetArrayItem(items.Medals,item) then
        class = "Medals"
    else
        class = nil
    end
    return class
end

return service</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="48">
        <Properties>
          <string name="Name">MarketService</string>
          <string name="Source">local service = {}

local wait = task.wait
local market = require(game.ReplicatedStorage.MarketPlace.MarketData)
local class = require(game.ReplicatedStorage.PublicDependancies.ClassService)

function service.GetArrayItem(array,item)
    for i,v in pairs(array) do
        if v.Name == item then
            return v
        else end
    return false
    end
end

function service:Initialize(plr)
	--Initialize the system
	warn("This system is experimental. It does not save any data at all. Make sure you use everything as you will lose it upon leaving the game.")
	if workspace:FindFirstChild(tostring(plr.Name.." Inventory")) then
		warn("This player's data already exist. Overwriting with a new folder...")
		workspace[plr.Name.." Inventory"]:Destroy()
	else
		print("Writing new folder for player")
	end
	local folder = Instance.new("Folder", workspace)
	folder.Name = tostring(plr.Name.." Inventory")
end

function service:LoadMarket(frame,template)
	--loop through the marketplace and add all for sale items to the ui
	if frame and template then
		for i,v in pairs(market) do
			local copy = template:Clone()
			copy.Name = v.Name
			copy.NameBox.Text = v.Name
			copy.Desc.Text = v.desc
			-- TODO: Use UI Service to make a viewport frame.
			copy.Parent = frame
		end
	else
		return "Build Error."
	end
end

function service:getItemDesc(item)
	--Get the description of items.
	local itemExist = service.GetArrayItem(market,item)
	if itemExist then
		return market[item].desc
	else
		return nil
	end
end

function getInventory(plr,frame,template)
	if plr then
		if workspace:FindFirstChild(tostring(plr.Name.." Inventory")) then
			for i,v in pairs(workspace[plr.Name.." Inventory"]:GetChildren()) do
				if v:FindFirstChild("className") then
					print(v.Name)
					if frame and template then
						local copy = template:Clone()
						copy.Name = v.Name
						copy.NameBox.Text = v.Name
						copy.Desc.Text = v.desc
						copy.Parent = frame
					end
				end
			end
		end
	else
		warn("No player found.")
	end
end

function service:PurchaseItem(item,plr)
	--Purchase the item and add it to the inventory folder.
	local itemExist = service.GetArrayItem(market,item)
	if item and plr and itemExist then
		local money = plr.ChaoStats.Rings -->Use a temporary ring system now 
		if money and money.Value >=  item.Price then
			money.Value -= item.Price
			local myItem = class:GetItem(item)
			myItem.Parent = workspace[plr.Name.." Inventory"]
		end
	else
		warn("PurchaseItem run error. Item: "..item.."plr "..plr.Name)
	end
end

function service:SellItem(item,plr)
	--Sell an item for 70% of its origin value.
	local itemExist = service.GetArrayItem(market,item)
	if itemExist then
		local salePrice = (market[item].Price * 70)/100
		local money = plr.ChaoStats.Rings
		money.Value += salePrice
		if workspace[plr.Name.." Inventory"]:FindFirstChild(item.Name) then
			--Delete the item when they sell it.
			workspace[plr.Name.." Inventory"][item.Name]:Destroy()
			if salePrice >= 10000 then
				money.Value += 2500 -- A small bonus for selling an expensive item
			end
		end
	end
end

return service</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="49">
        <Properties>
          <string name="Name">UIService</string>
          <string name="Source"><![CDATA[local module = {}

local changeSignals = {
	"Context",
	"Input",
	"ConsoleInput",
	"ObjectText",
	"Name"
}

function module:GenerateContextMenu(context,obj,Input,cInput,objectText)
	if context and obj then
		local contextMenu = Instance.new("ProximityPrompt")
		contextMenu.Name = context
		contextMenu.ActionText = context
		if Input then
			contextMenu.KeyboardKeyCode = Input
		end
		if cInput then
			contextMenu.GamepadKeyCode = cInput
		end
		if objectText then
			contextMenu.ObjectText = objectText
		end
		contextMenu.MaxActivationDistance = 15
		contextMenu.Parent = obj
	else
		warn("Missing Inputs")
	end
end

function module:UpdateContextMenu(obj,changeSignal,ctx)
	if obj and obj:IsA("ProximityPrompt") then
		if table.find(changeSignals,changeSignal,1) then
			if changeSignal == "Context" then
				obj.ActionText = ctx
			end
			if  changeSignal == "Input" then
				obj.KeyboardKeyCode = ctx
			end
			if changeSignal == "ConsoleInput" then
				obj.GamepadKeyCode = ctx
			end
			if changeSignal == "ObjectText" then
				obj.ObjectText = ctx
			end
			if changeSignal == "Name" then
				obj.Name = ctx
			end
		else
			warn("Invalid Change Signal")
		end
	else
		warn("Attempted to update nil or invalid object.")
	end
end

function module:DestroyContextMenu(contextMenu)
	if contextMenu and contextMenu:IsA("ProximityPrompt") then
		contextMenu:Destroy()
		print("Destoyed Secessfully.")
	else
		warn("Attempted to destroy nil or invalid object")
	end
end

function module:GetContextMenuProperty(obj,property)
	if obj and obj:IsA("ProximityPrompt") then
		if table.find(changeSignals,property,1) then
			if property == "Context" then
				return obj.ActionText
			end
			if property == "Input" then
				return obj.KeyboardKeyCode
			end
			if property == "ConsoleInput" then
				return obj.GamepadKeyCode
			end
			if property == "ObjectText" then
				return obj.ObjectText
			end
			if property == "Name" then
				return obj.Name
			end
		end
	else
		warn("Unable to get proprties of nil or invalid object.")
	end
end

function module:CreateChaoViewPort(chao, object, corner)
	if chao and chao:FindFirstChild("HumanoidRootPart") and object then
		local copyChao = chao:Clone()
		copyChao:MoveTo(Vector3.new(0,0,0))
		local id = Instance.new("StringValue", copyChao)
		id.Value = chao.Name
		id.Name = "Id"
		copyChao.Name = "TempChao"
		copyChao.Parent = workspace
		local frame = Instance.new("ViewportFrame")
		frame.AnchorPoint = UDim.new(0,0)
		frame.Size = UDim2.new(1,0,1,0)
		frame.Position = UDim2.new(0,0,0,0)
		frame.BackgroundTransparency = 1
		frame.Parent = object
		local cam = Instance.new("Camera")
		cam.Parent = frame
		print(cam.Parent.Name)
		cam.FieldOfView = 45
		frame.CurrentCamera = cam
		local humroot = chao:FindFirstChild("HumanoidRootPart")
		cam.CFrame = CFrame.new(Vector3.new(0,2,12), humroot.Position)
		if corner then
			local uicorner = Instance.new("UICorner")
			uicorner.CornerRadius = UDim.new(0,20)
		end
	end
end


return module
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="50">
        <Properties>
          <string name="Name">VisualService</string>
          <string name="Source">--A service used to changethe visual appearance of chao based on their stats
local service = {}

--A Class Table for Emotion Ball Types
local headTypes = {
    Hero = {
        Name = "Hero",
        ID = ""
    },
    Dark = {
        Name = "Dark",
        ID = ""
    },
    Normal = {
        Name = "Normal",
        ID = ""
    },
}

function service.GetArrayItem(item,array)
    for i,v in pairs(array) do
        if v.Name == item then
            return v
        else end
    return false
    end
end

function service:ChangeHeadType(chao,headType)
    if service.GetArrayItem(headTypes,headType)  then
        chao.Emotion.MeshPart.Mesh = service.GetArrayItem(headTypes,headType).ID
        print("HeadType Changed")
    else
        warn("Invalid HeadType")
    end
end

function service:ChangeChaoType(chao,chaoType)
    
end

return service</string>
        </Properties>
      </Item>
    </Item>
    <Item class="Model" referent="51">
      <Properties>
        <string name="Name">baseChao</string>
      </Properties>
      <Item class="Part" referent="52">
        <Properties>
          <string name="Name">HumanoidRootPart</string>
        </Properties>
        <Item class="Script" referent="53">
          <Properties>
            <string name="Name">PickScript</string>
            <string name="Source">--Makes it so you can pick up your chao and throw it
local wait = task.wait
--dependancies
local UIService = require(game.ReplicatedStorage.PublicDependancies.UIService)
UIService:GenerateContextMenu("Pick",script.Parent,Enum.KeyCode.E,Enum.KeyCode.ButtonX,"Pick up your chao.")
UIService:UpdateContextMenu(script.Parent.Pick,"Name","Pickup")
UIService:GenerateContextMenu("Pet",script.Parent,Enum.KeyCode.Q,Enum.KeyCode.ButtonY, "Pet Your Chao.")

while wait(1) do
	local pickupStatus = UIService:GetContextMenuProperty(script.Parent.Pickup,"Context")
	if script.Parent.Held.Value == false then
		if pickupStatus ~= "Pick" then
			UIService:UpdateContextMenu(script.Parent.Pickup,"Context","Pick")
			UIService:UpdateContextMenu(script.Parent.Pickup,"ObjectText","Pick up your chao.")
		end
	else
		if script.Parent.Parent:FindFirstChild("HumanoidRootPart") then
			local velo = script.Parent.Parent.HumanoidRootPart.Velocity.Magnitude
			print("Velocity: "..velo)--Actually print the velocity.
			if velo >= 2 then
				if pickupStatus ~= "Throw" then
					UIService:UpdateContextMenu(script.Parent.Pickup,"Context","Throw")
					UIService:UpdateContextMenu(script.Parent.Pickup,"ObjectText","Throw your chao.")				
				end
			else
				if pickupStatus ~= "Drop" then
					UIService:UpdateContextMenu(script.Parent.Pickup,"Context","Drop")
					UIService:UpdateContextMenu(script.Parent.Pickup,"ObjectText","Place your chao down.")				
				end
			end
		end
	end
end</string>
          </Properties>
        </Item>
      </Item>
      <Item class="Script" referent="54">
        <Properties>
          <string name="Name">Movement</string>
          <string name="Source">math.randomseed(tick())
--Services
local PFS = game:GetService("PathfindingService")
local path = PFS:CreatePath()
local pathinprogress = false

--update wait()
local wait = task.wait

--TODO: Add states that the chao can use to show the correct animation.
--[[
	States
	Walk --> Chao is walking around.
	Normal --> The Idle State.
	Thinking --> The State that comes right before the walk state. The chao is deciding what to do.
	Sleeping --> The chao is recharging it energy.
]]

function followPath(object, goal)
	local waypoints
	local hum = object.Parent.Humanoid
	local humroot = object.Parent.HumanoidRootPart
	local success, failed = pcall(function()
		path:ComputeAsync(object.Position, goal)
	end)

	if success and path.Status == Enum.PathStatus.Success then
		waypoints = path:GetWaypoints()
		for i, waypoint in pairs(waypoints) do
			if script.Parent.Held.Value == false then
				if waypoint.Action == Enum.PathWaypointAction.Jump then
					wait(1) --make the chao pause before jumping
					hum:ChangeState(Enum.HumanoidStateType.Jumping)
				end
				humroot:MoveTo(waypoint.Position)
				humroot.MoveToFinished:Wait(1)
			else
				break
			end
		end
		pathinprogress = false
	else
		warn("Unable to compute path. "..tostring(failed))
	end
end

local function generateMovement()
	local startPos = script.Parent.HumanoidRootPart.Position
	local walls = workspace.Walls
	local outsideForce = false
	local randomVector
	for i, v in pairs(walls:GetChildren()) do
		local magnitude = (startPos.Magnitude - v.Position.Magnitude)
		if magnitude &lt;= 100 then
			--return them to the center
			outsideForce = true
			randomVector = Vector3.new(0,0,0) --where the origin will be
		end
	end
	if outsideForce == false then
		--Move around 100 studs
		randomVector = Vector3.new(startPos.X+math.random(-100,100),startPos.Y,startPos.Z+math.random(-100,100)) --add
	end
	followPath(script.Parent.HumanoidRootPart, randomVector)
end


wait(5)

while wait(1) do
	if script.Parent.Parent == workspace then
		if script.Parent.Held.Value == false then
			if pathinprogress == false then
				generateMovement()
			end
		end
	end
end</string>
        </Properties>
      </Item>
      <Item class="Script" referent="55">
        <Properties>
          <string name="Name">States</string>
          <string name="Source">local chao = script.Parent
local hum = script.Parent.Humanoid
local RS = game:GetService("RunService")

RS.Heartbeat:Connect(function()
    local currentlyPlaying = nil
    local anim = Instance.new("Animation")
    local humState = hum:GetState()
    if humState == Enum.HumanoidStateType.Running then
        if currentlyPlaying ~= "Running" then
            currentlyPlaying =  "Running"
            if anim.IsPlaying == true then
                anim:Stop()
            end
            anim.Id = "rbxassetid://" --Make anim
            hum.Animator:LoadAnimation(anim)
            anim:Play()
        end
    else
        if currentlyPlaying ~= "Idle" then
            currentlyPlaying =  "Idle"
            if anim.IsPlaying == true then
                anim:Stop()
            end
            anim.Id = "rbxassetid://" --Make anim
            hum.Animator:LoadAnimation(anim)
            anim:Play()
        end
    end
end)</string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="56">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Script" referent="57">
      <Properties>
        <string name="Name">Age</string>
        <string name="Source">--Define the player and the chao's Data
local chaoData = script.Parent.Name
local chaoModule = require(game.ReplicatedStorage.PublicDependancies.ChaoModule)

game.Players.PlayerAdded:Connect(function(player)
    repeat
        wait()
    until script.Parent == workspace
    while wait() do
        if player.Leaderstats:FindFirstChild(chaoData) then
            if not workspace.currentGarden.Value == "Lobby" and player.Leaderstats[chaoData].canAge == true then
                player.Leaderstats[chaoData].Age.Value += 0.00055
                if player.Leaderstats[chaoData].Age.Value >= 1 and script.Parent.Held == false and player.Leaderstats[chaoData].Ability == "Child" then
                    -- chaoModule
                    chaoModule:Evo(player.Leaderstats[chaoData],script.Parent,player)
                elseif player.Leaderstats[chaoData].Age.Value >= 4 and script.Parent.Held == false then
                    if player.Leaderstats[chaoData].Happiness.Value >= 50 then
                        --Pink Cocoon (Rebirth)
                        chaoModule:Rebirth(player.Leaderstats[chaoData],script.Parent,player)
                    else
                        --White cocoon (death)
                        chaoModule:RemoveChao(player.Leaderstats[chaoData],script.Parent,player)
                    end
                end
            end
        end
    end
end)</string>
      </Properties>
    </Item>
    <Item class="Script" referent="58">
      <Properties>
        <string name="Name">ContextMenuController</string>
        <string name="Source">local PromptService = game:GetService("ProximityPromptService")
local UIService = require(game.ReplicatedStorage.PublicDependancies.UIService)
local chaoModule = require(game.ReplicatedStorage.PublicDependancies.ChaoModule)

PromptService.PromptTriggered:Connect(function(prompt, player)
	if prompt and player then
		local promptStatus = UIService:GetContextMenuProperty(prompt,"Context")
		if prompt.Name == "Pet" then
			local chao = prompt.Parent
			chao.Held.Value = true
			--Play petting anim and sound
			wait(1)
			chaoModule.changeData("Happiness",1,player.ChaoData)
			chaoModule.changeData("AbilityDirection",0.33,player.ChaoData)
			chao.Held.Value = false
		end
		if prompt.Name == "Pickup" then
			if promptStatus == "Pick" then
				prompt.Parent.Held.Value = true
				prompt.Parent.Parent = player.Character
				--Load Carry Animation
				--Weld to the player
				local humroot = player.Character:FindFirstChild("HumanoidRootPart")
				local chao = prompt.Parent
				chao.CFrame = humroot.CFrame * CFrame.new(0,0,-1)
				local weld = Instance.new("WeldConstraint")
				weld.Part0 = humroot
				weld.Part1 = chao
				weld.Name = "Weld"
				weld.Parent = chao
			end
			if promptStatus == "Drop" then
				local chao = prompt.Parent
				if chao:FindFirstChild("Weld") then
					chao.Held.Value = false
					chao.Weld:Destroy()
					chao.Parent = workspace
				end
			end
			if promptStatus == "Throw" then
				local chao = prompt.Parent
				if chao:FindFirstChild("Weld") then
					chao.Held.Value = false
					local lookVector = chao.Parent.HumanoidRootPart.CFrame.LookVector
					chao.Weld:Destroy()
					chao.Parent = workspace
					chao.Velocity = chao.CFrame:VectorToWorldSpace(Vector3.new(0, 0, -300))
					chaoModule.changeData("Happiness",-1,player.ChaoData)
					chaoModule.changeData("AbilityDirection",-0.03,player.ChaoData)
					if chao.Name == "Egg" then
						chaoModule.newChao()
						chaoModule.Hatch(chao)
					end
				end
			end
		end
		if prompt.Name == "ChaoDrive" then
			local promptStatus = UIService:GetContextMenuProperty(prompt,"Context")
			if promptStatus == "Pickup" then
				prompt.Parent.Held.Value = true
				prompt.Parent.Parent = player.Character
				local humroot = player.Character:FindFirstChild("HumanoidRootPart")
				local chao = prompt.Parent
				chao.CFrame = humroot.CFrame * CFrame.new(0,0,-1)
				local weld = Instance.new("WeldConstraint")
				weld.Part0 = humroot
				weld.Part1 = chao
				weld.Name = "Weld"
				weld.Parent = chao
			end
			if promptStatus == "Drop" then
				local chao = prompt.Parent
				if chao:FindFirstChild("Weld") then
					chao.Held.Value = false
					chao.Weld:Destroy()
					chao.Parent = workspace
				end
			end
		end
	end
end)</string>
      </Properties>
    </Item>
    <Item class="Script" referent="59">
      <Properties>
        <string name="Name">Datastore</string>
        <string name="Source">--TODO: Improve this
local module = require(game.ReplicatedStorage.PublicDependancies.ChaoModule)-->Datastore uses folder from ChaoModule
local Datastore = game:GetService("DataStoreService")
local saveData = Datastore:GetDataStore("Sonic Earth Chao Garden")

game.Players.PlayerAdded:Connect(function(player)
	if player and module then
		wait(2)
		local folder = game.ReplicatedStorage.Folder:Clone()
		folder.Name = "ChaoData"
		folder.Parent = player
		--load data
		local data

		local success, errormessage = pcall(function(player)
			data = saveData:GetAsync("User_"..player.UserId) --finish this
		end)

		if success then
			--set values
			folder.Ability.Value = data.Ability
			folder.Age.Value = data.Age
			folder.Attribute.Value = data.Attribute
			folder.ChaoName.Value = data.ChaoName
			folder.Class.Value = data.ChaoClass
			folder.Condition.Value = data.Condition
			folder.FlyLevel.Value = data.FlyLevel
			folder.FlyRank.Value = data.FlyRank
			folder.FlyXP.Value = data.FlyXP
			folder.Happiness.Value = data.Happiness
			folder.Happiness.Value = data.Hunger
			folder.Hatched.Value = data.Hatched
			folder.Personality.Value = data.Personality
			folder.PowerLevel.Value = data.PowerLevel
			folder.PowerRank.Value = data.PowerRank
			folder.PowerXP.Value = data.PowerXP
			folder.RunLevel.Value = data.RunLevel
			folder.RunRank.Value = data.RunRank
			folder.RunXP.Value = data.RunXP
			folder.StaminaLevel.Value = data.StaminaLevel
			folder.StaminaRank.Value = data.StaminaRank
			folder.StaminaXP.Value = data.StaminaXP
			folder.SwimLevel.Value = data.SwimLevel
			folder.SwimXP.Value = data.SwimXP
			folder.spawn.Value = data.spawm
		end
	else
		warn("An error occured while loading data.")
	end
end)

--game.Players.PlayerRemoving:Connect(function(player)
--	local data = {}
--	for i,v in pairs(player.ChaoData:GetChildren()) do
--		table.insert(data, v.Value)
--	end
--	local success, errormessage = pcall(function()
--		saveData:SetAsync("User_"..player.UserId, data)
--	end)
--	if success then
--		print("Save Data Saved Sucessfully!")
--	else
--		warn("An Error Occured while saving save data to server")
--		warn(errormessage)
--	end
--end)</string>
      </Properties>
    </Item>
    <Item class="Script" referent="60">
      <Properties>
        <string name="Name">EatChaoDrive</string>
        <string name="Source">local remote = game.ReplicatedStorage.Remotes.Eat
local chaoModule = require(game.ReplicatedStorage.PublicDependancies.ChaoModule)

remote.OnServerEvent:Connect(function(stat,value,chaoData,objClass,obj)
	print("fired!")
	print(objClass)
	if objClass == "Drive" then
		chaoModule.changeStat(stat,value,chaoData)
	end
	if objClass == "Fruit" then
		chaoModule.changeStat(stat,value,chaoData)
		--Chao are happier when feed
		chaoModule.changeData("Hunger",-value,ChaoData)
		chaoModule.changeData("Happiness",1,ChaoData)
		--Since Shadow isn't in the game, we'll just always change it to positive. So they'll need to buy lots of dark fruit or mean to get a dark chao
		chaoModule.changeData("AbilityDirection",0.33,ChaoData)
	end
	if objClass == "Wisp" then
		chaoModule.changeStat(stat,value,chaoData)
	end
	--Play Anim and Sound
	wait(0.2)
	obj:Destroy()
end)</string>
      </Properties>
    </Item>
    <Item class="Script" referent="61">
      <Properties>
        <string name="Name">LocalTeleportService</string>
        <string name="Source">local debound = false
local wait = task.wait
local garden = workspace.currentGarden

function getDoors(doorName)
	local found = false
	for i,v in pairs(workspace.Doors.Gate:GetChildren()) do
		local temp = v:GetAttribute("DoorName")
		if temp == doorName then
			found = true
			return v.Position
		end
	end
	if found == false then
		return false
	end
end

while wait() do
	for i,v in pairs(workspace.Doors:GetChildren()) do
		if debound == false then
			if v:IsA("Part") then
				debound = true
				v.Touched:Connect(function(hit)
					if hit.Parent:FindFirstChild("Humanoid") then
						local isReturn = v:GetAttribute("isReturn")
						local doorName = v:GetAttribute("DoorName")
						if doorName then
							local goal = getDoors(doorName)
							if goal then
								hit.Parent.HumanoidRootPart.Position = goal
								garden.Value = doorName
							end
						end
					end
				end)
				debound = false
			end
		end
	end
end



--function getDoors(doorName)
--	for l,z in pairs(workspace.Doors.Gate:GetChildren()) do
--		local temp = z:GetAttribute("DoorName")
--		if temp == doorName then
--			return z.Position
--			print("Found it!")
--		end
--	end
--end</string>
      </Properties>
    </Item>
    <Item class="Script" referent="62">
      <Properties>
        <string name="Name">Main</string>
        <string name="Source">-- local chaoModule = require(game.ReplicatedStorage.PublicDependancies.ChaoModule)

-- game.Players.PlayerAdded:Connect(function(plr)
-- 	if plr then
-- 		wait(1)
-- 		if plr:FindFirstChild("Leaderstats")
-- 	end
-- end)</string>
      </Properties>
    </Item>
    <Item class="Script" referent="63">
      <Properties>
        <string name="Name">NeoDatastore</string>
        <string name="Source">local Datastore = game:GetService("DataStoreService")
local saveData = Datastore:GetDataStore("Sonic Earth Chao Garden Alpha")
--Instead of generating a new folder every time with the old Main script simply generate a new folder only if we need to.
local module = require(game.ReplicatedStorage.PublicDependancies.ChaoModule)

game.Players.PlayerAdded:Connect(function(player)
	workspace.currentGarden.Value = "Lobby"
	if player and module then
		--Create a chaoData folder
		local main = Instance.new("Folder")
		main.Name = "Leaderstats"
		main.Parent = player
		--Create the folder for the data
		local folder = game.ReplicatedStorage.Folder:Clone()
		--Don't change the name. We'll be naming it to the chao's name
		folder.Parent = main
		--load data
		local data = saveData:GetAsync("User_"..player.UserId)
		
		if data then
			for i,v in pairs(folder:GetChildren()) do
				v.Value = data[v]
			end
			folder.Name = data.ChaoName
		else
			print("Creating new data!")
			module.newChao()
			print("SaveData Ready")
		end
	end
end)

function createSaveTable(player)
	local saveTable = {}
	for i,v in pairs(player.Main:GetDescendants()) do
		if not v:IsA("Folder") then
			saveTable[v.Name] = v.Value
		end
	end
	return saveTable
end

game.Players.PlayerRemoving:Connect(function(player)
	local data = createSaveTable(player)
	local success, errormessage = pcall(function()
		saveData:SetAsync("User_"..player.UserId, data)
	end)
	if success then
		print("Save Data Saved Sucessfully!")
	else
		warn("An Error Occured while saving save data to server")
		warn(errormessage)
	end
end)</string>
      </Properties>
    </Item>
    <Item class="Script" referent="64">
      <Properties>
        <string name="Name">WorldHandle</string>
        <string name="Source">local theme = workspace.Theme --No need for AudioAttempt for now.
local garden = workspace.currentGarden
local chaoWorld = "rbxassetid://397169354" --Temporary
local neutGarden = "rbxassetid://186088305"
local Kinder = ""
local loading = ""

wait(4)
print("Ready!")
garden.Value = "none"

garden.Changed:Connect(function()
	if garden.Value == "Garden" then
		theme.SoundId = neutGarden
	elseif garden.Value == "Kindergarden" then
		theme.SoundId = Kinder
	else
		theme.SoundId = chaoWorld
	end
end)</string>
      </Properties>
    </Item>
  </Item>
  <Item class="StarterGui" referent="65">
    <Properties>
      <string name="Name">StarterGui</string>
    </Properties>
    <Item class="ScreenGui" referent="66">
      <Properties>
        <string name="Name">Backpack</string>
      </Properties>
      <Item class="Frame" referent="67">
        <Properties>
          <string name="Name">Frame</string>
        </Properties>
        <Item class="LocalScript" referent="68">
          <Properties>
            <string name="Name">LocalScript</string>
            <string name="Source">local UIS = game:GetService("UserInputService")

UIS.InputBegan:Connect(function(input)
	if input.KeyCode == Enum.KeyCode.E then
		if script.Parent.Visible == true then
			script.Parent.Visible = false
		else
			script.Parent.Visible = true
		end
	end
end)</string>
          </Properties>
        </Item>
      </Item>
    </Item>
    <Item class="ScreenGui" referent="69">
      <Properties>
        <string name="Name">Classroom</string>
      </Properties>
      <Item class="LocalScript" referent="70">
        <Properties>
          <string name="Name">DoctorUI</string>
          <string name="Source">local chaoService = require(game.ReplicatedStorage.PublicDependancies.ChaoModule)
local UIService = require(game.ReplicatedStorage.PublicDependancies.UIService)
local UIS = game:GetService("UserInputService")

local on = true

normalReply = {
	"Oh no! Your chao is perfectly healthy.";
	"Your chao seems fine.";
	"Nothing is wrong with your chao.";
	"Your chao is very healthy!";
	"Your chao isn't sick."
}

function write()
	local rng = math.random(#normalReply)
	local text = normalReply[rng]
	for i = 1, #text do
		script.Parent.TextLabel.Text = string.sub(text, 1, i)
		wait(0.03)
	end
	on = false
end

function fillData(chaoData)
	--Uses the chaoService:GetStat() to set the data of the pages. Also UIService:CreateChaoViewPort() for the first page with the visial of your chao. 
	--Basic Frame
	local topFrame = script.Parent.Frame
	local basic = topFrame.Basic
	local chao = workspace.TempChao
	basic.Attributes.Text = chaoService:GetStats(chao.Id.Value,game.Players.LocalPlayer,"Attribute")
end

while wait() do
	if on == true then
		for i,v in pairs(script.Parent.Start:GetChildren()) do
			if v:IsA("TextButton") then
				v.MouseEnter:Connect(function()
					v.UIStroke.Thickness = 5
				end)
				v.MouseLeave:Connect(function()
					v.UIStroke.Thickness = 0
				end)
				v.MouseButton1Click:Connect(function()
					if v.Name == "Look" then
						on = false
						write()
					elseif v.Name == "Charts" then
						script.Parent.Start.Visible = false
						script.Parent.Frame.Visible = true
					end
				end)
			end
		end
	end
end</string>
        </Properties>
      </Item>
    </Item>
    <Item class="LocalScript" referent="71">
      <Properties>
        <string name="Name">UI</string>
        <string name="Source">local UIService = require(game.ReplicatedStorage.PublicDependancies.UIService)

local ui = script.Parent.ScreenGui.Frame.GardenLogo
local garden = workspace.currentGarden

game.Players.PlayerAdded:Connect(function()
	print("New Player!")
	repeat wait(1) until game.Players.LocalPlayer.CharacterAppearanceLoaded == true
	print("Ready!")
	ui.Visible = true
	ui.Image = "rbxassetid://8596805320"
	wait(3)
	ui.Visible = false
end)

garden.Changed:Connect(function()
	print(garden.Value)
	if garden.Value ~= "loading" then
		ui.Visible = true
		if garden.Value == "Garden" then
			ui.Image = "rbxassetid://8596788034"
		elseif garden.Value == "Kindergarden" then
			ui.Image = "rbxassetid://8596801475"
		else
			ui.Image = "rbxassetid://8596805320"
		end
		wait(3)
		ui.Visible = false
	else
		script.Parent.ScreenGui.Fade.Visible = true
		wait(1.5)
		script.Parent.ScreenGui.Fade.Visible = false
	end
end)

local plr = game.Players.LocalPlayer

workspace.kinder.Doctor.Touched:Connect(function(hit)
	if hit.Parent:FindFirstChild("Humanoid") then
		local chaoExistence = plr.Character:FindFirstChild("Held", true)
		if chaoExistence then
			script.Parent.Classroom.Start.Visible = true
			local chao = chaoExistence.Parent
			UIService:CreateViewPort(chao,script.Parent.Basic,true)
		end
	end
end)</string>
      </Properties>
    </Item>
  </Item>
  <Item class="StarterPlayer" referent="72">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterCharacterScripts" referent="73">
      <Properties>
        <string name="Name">StarterCharacterScripts</string>
      </Properties>
      <Item class="LocalScript" referent="74">
        <Properties>
          <string name="Name">Animate</string>
          <string name="Source"><![CDATA[local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local animateScriptEmoteHookFlagExists, animateScriptEmoteHookFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserAnimateScriptEmoteHook")
end)
local FFlagAnimateScriptEmoteHook = animateScriptEmoteHookFlagExists and animateScriptEmoteHookFlagEnabled

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
		{ id = "http://www.roblox.com/asset/?id=8311784209", weight = 1 },
		{ id = "http://www.roblox.com/asset/?id=8311784209", weight = 1 },
		{ id = "http://www.roblox.com/asset/?id=8311784209", weight = 9 }
	},
	walk = 	{ 	
		{ id = "http://www.roblox.com/asset/?id=8311691667", weight = 10 } 
	}, 
	run = 	{
		{ id = "http://www.roblox.com/asset/?id=8311757370", weight = 10 } 
	}, 
	swim = 	{
		{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
	}, 
	swimidle = 	{
		{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
	}, 
	jump = 	{
		{ id = "http://www.roblox.com/asset/?id=8311751167", weight = 10 } 
	}, 
	fall = 	{
		{ id = "http://www.roblox.com/asset/?id=8311789859", weight = 10 } 
	}, 
	climb = {
		{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
	}, 
	sit = 	{
		{ id = "http://www.roblox.com/asset/?id=5954894701", weight = 10 } 
	},	
	toolnone = {
		{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
	},
	toolslash = {
		{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
	},
	toollunge = {
		{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
	},
	wave = {
		{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
	},
	point = {
		{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
	},
	dance = {
		{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
		{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
		{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
	},
	dance2 = {
		{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
		{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
		{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
	},
	dance3 = {
		{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
		{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
		{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
	},
	laugh = {
		{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
	},
	cheer = {
		{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
	},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end

	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end

	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))

		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end

	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end

	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	if FFlagAnimateScriptEmoteHook and currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end

	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end

	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			return 1
		end

		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return 1
end

local smallButNotZero = 0.0001
function setRunSpeed(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale

	if runSpeed ~= currentAnimSpeed then
		if runSpeed < 7.33 then
			currentAnimTrack:AdjustWeight(8.0)		
			runAnimTrack:AdjustWeight(smallButNotZero)
		elseif runSpeed < 5.66 then
			local weight = ((runSpeed - 5.33) / 5.33)
			currentAnimTrack:AdjustWeight(8.0 - weight + smallButNotZero)
			runAnimTrack:AdjustWeight(weight + smallButNotZero)
		else
			currentAnimTrack:AdjustWeight(smallButNotZero)
			runAnimTrack:AdjustWeight(8.0)
		end
		currentAnimSpeed = runSpeed
		runAnimTrack:AdjustSpeed(runSpeed)
		currentAnimTrack:AdjustSpeed(runSpeed)
	end	
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
		setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end

			if FFlagAnimateScriptEmoteHook and currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end

				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end

			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then

		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0

		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core

		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)

		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		

			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	if (toolAnimInstance ~= anim) then

		if (toolAnimTrack ~= nil) then
			toolAnimTrack:Stop()
			toolAnimTrack:Destroy()
			transitionTime = 0
		end

		-- load it to the humanoid; get AnimationTrack
		toolAnimTrack = humanoid:LoadAnimation(anim)
		if priority then
			toolAnimTrack.Priority = priority
		end

		-- play the animation
		toolAnimTrack:Play(transitionTime)
		toolAnimName = animName
		toolAnimInstance = anim

		currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
	end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)	
	if speed > 0.75 then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end


function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
	local deltaTime = currentTime - lastTick
	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

	if (jumpAnimTime > 0) then
		jumpAnimTime = jumpAnimTime - deltaTime
	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = wait(0.1)
	stepAnimate(currentGameTime)
end

]]></string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="75">
        <Properties>
          <string name="Name">Feed</string>
          <string name="Source">--Checks when the player gives a Chao a drive

--Prevents the same even from firing forever.
local debound = false
--The remote event that the chao drive handler uses.
local remote = game.ReplicatedStorage.Remotes.Eat
--Get ClassService
local classService = require(game.ReplicatedStorage.PublicDependancies.ClassService)
math.randomseed(tick())
local wait = task.wait

--run the function forever without crashing.
while wait() do
	for i,v in pairs(workspace:GetChildren()) do
		local myClass = classService:GetItemsClass(v.ChaoClass)
		if myClass == "Drive" then
			if debound == false then
				debound = true
				if v.Name == "FlyDrive" then
					v.Touched:Connect(function(hit)
						if hit:FindFirstChild("Held") then
							remote:FireServer("Fly",math.random(3,6),v.Name,"Drive",v)
						end
					end)
				end
				if v.Name == "PowerDrive" then
					v.Touched:Connect(function(hit)
						if hit.Parent:FindFirstChild("Held") then
							remote:FireServer("Power",math.random(3,6),v.Name,"Drive",v)
						end
					end)
				end
				if v.Name == "RunDrive" then
					v.Touched:Connect(function(hit)
						if hit.Parent:FindFirstChild("Held") then
							remote:FireServer("Run",math.random(3,6),v.Name,"Drive",v)
						end
					end)
				end
				if v.Name == "SwimDrive" then
					v.Touched:Connect(function(hit)
						if hit.Parent:FindFirstChild("Held") then
							remote:FireServer("Swim",math.random(3,6),v.Name,"Drive",v)
						end
					end)
				end
				debound = false
			end
		end
		if myClass == "Fruit" then
			if debound == false then
				debound = true
				if v.Name == "SkillsFruit" then
					v.Touched:Connect(function(hit)
						if hit.Parent:FindFirstChild("Held") then
							remote:FireServer("Skill",math.random(3,10),v.Name,"Fruit",v)
						end
					end)
				end
			end
		end
	end
end</string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="76">
        <Properties>
          <string name="Name">Shake</string>
          <string name="Source">local UIS = game:GetService("UserInputService")

local shakeBind = Enum.KeyCode.X
local debounce = false


UIS.InputBegan:Connect(function(input)
	if input.KeyCode == shakeBind then
		if script.Parent:FindFirstChild("Egg") and debounce == false then
			debounce = true
			--Play Shake Tween or smth
			script.Parent.Egg.HatchTime -= 20
			print("Shoke")
			wait(2)
			debounce = false
		end
	end
end)</string>
        </Properties>
      </Item>
    </Item>
  </Item>
</roblox>