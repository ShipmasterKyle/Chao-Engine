<roblox version="4">
  <Item class="ReplicatedStorage" referent="0">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="MeshPart" referent="1">
      <Properties>
        <string name="Name">Egg</string>
      </Properties>
      <Item class="Script" referent="2">
        <Properties>
          <string name="Name">AutoHatch</string>
          <string name="Source">--[[
	AutoHatch
	Handles hatching the egg without shaking it.
]]

--Get Dependancies
local UIService = require(game.ReplicatedStorage.PublicDependancies.UIService)
local chaoModule = require(game.ReplicatedStorage.PublicDependancies.ChaoModule)
local wait = task.wait

--Runs every second
while wait(1) do
	if script.Parent.Held.Value == false then
		if script.Parent.HatchTime.Value &lt;= 0 then
			if script.Parent:FindFirstChild("Identifier") then
				chaoModule.Hatch(script.Parent,true)
			else
				chaoModule.Hatch(script.Parent)
			end
		else
			script.Parent.HatchTime.Value -= 1
		end
	end
end</string>
        </Properties>
      </Item>
      <Item class="Script" referent="3">
        <Properties>
          <string name="Name">Killvelocity</string>
          <string name="Source">--[[
	KillVelocity
	Stops Velocity when throughing the egg.
]]
script.Parent.Touched:Connect(function(hit)
	if hit.Parent.Name == "Wall" then
		script.Parent.Velocity *= 0
	end
end)</string>
        </Properties>
      </Item>
      <Item class="Script" referent="4">
        <Properties>
          <string name="Name">PickScript</string>
          <string name="Source"><![CDATA[--Makes it so you can pick up the egg and throw it
local wait = task.wait
--dependancies
local UIService = require(game.ReplicatedStorage.PublicDependancies.UIService)
UIService:GenerateContextMenu("Pick",script.Parent,Enum.KeyCode.E,Enum.KeyCode.ButtonX,"Pick up your chao.")
UIService:UpdateContextMenu(script.Parent.Pick,"Name","Pickup")

--Run every second
while wait(1) do
	local pickupStatus = UIService:GetContextMenuProperty(script.Parent.Pickup,"Context")
	if script.Parent.Held.Value == false then
		if pickupStatus ~= "Pick" then
			UIService:UpdateContextMenu(script.Parent.Pickup,"Context","Pick")
			UIService:UpdateContextMenu(script.Parent.Pickup,"ObjectText","Pick up your chao.")
		end
	else
		if script.Parent.Parent:FindFirstChild("HumanoidRootPart") then
			local velo = script.Parent.Parent.HumanoidRootPart.Velocity.Magnitude
			print("Velo")
			if velo >= 2 then
				if pickupStatus ~= "Throw" then
					UIService:UpdateContextMenu(script.Parent.Pickup,"Context","Throw")
					UIService:UpdateContextMenu(script.Parent.Pickup,"ObjectText","Throw your chao.")				
				end
			else
				if pickupStatus ~= "Drop" then
					UIService:UpdateContextMenu(script.Parent.Pickup,"Context","Drop")
					UIService:UpdateContextMenu(script.Parent.Pickup,"ObjectText","Place your chao down.")				
				end
			end
		end
	end
end

]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="5">
      <Properties>
        <string name="Name">MarketPlace</string>
      </Properties>
      <Item class="ModuleScript" referent="6">
        <Properties>
          <string name="Name">Class</string>
          <string name="Source">--[[
    Class
    A simple class tree for every item in the game.
]]

local tree = {
    Chao = {
        Name = "Chao",
        WoolHat = {
            Name = "Wool Hat",
            Desc = "A warm hat for your chao.",
            isDecor = true,
            Value = "1000",
        }
    },
    Food = {
        Name = "Food",
        Fruit = {
            Name = "Garden Fruit",
            Desc = "A regular fruit.",
            isDecor = false,
            Value = "50",
        },
        SFruit = {
            Name = "Square Fruit",
            Desc = "A square shaped fruit. Some chao love this.",
            isDecor = false,
            Value = "100"
        },
        RFruit = {
            Name = "Round Fruit",
            Desc = "A round shaped fruit. Some chao love this.",
            isDecor = false,
            Value = "125"
        },
        TFruit = {
            Name = "Triangle Fruit",
            Desc = "A triangle shaped fruit. Some chao love this.",
            isDecor = false,
            Value = "150"
        },
        StFruit = {
            Name = "Strong Fruit",
            Desc = "Help your chao grow stronger. (Power +4)",
            isDecor = false,
            Value = "200",
        },
        TaFruit = {
            Name = "Tasty Fruit",
            Desc = "A tasty fruit that all chao love. Its great for their health too.",
            isDecor = false,
            Value = "350",
        },
        HFruit = {
            Name = "Heart Fruit",
            Desc = "A sweet tasting fruit that gets chao ready to mate.",
            isDecor = false,
            Value = "500",
        },
        SMFruit = {
            Name = "Smart Fruit",
            Desc = "A fruit with riveting flavor that helps your chao learn.",
            isDecor = false,
            Value = "500",
        },
        Mint = {
            Name = "Mint Candy",
            Desc = "A lucky piece of candy sure to give your chao tons of energy. (Luck +25)",
            isDecor = false,
            Value = "800"
        }
    },
    Toys = {
        Name = "Toys",
        Car = {
            Name = "Toy Car",
            Desc = "A Toy Car that can be won from Chao Races",
            isDecor = false,
            Value = "-1000"
        }
    },
    Animals = {
        Name = "Animal",
        Wisps = {
            Name = "Wisps",
            White = {
                Name = "White Wisp",
                Desc = "The White Wisp. Helps make your chao faster. (Running +3)",
                isDecor = false,
                Value = "250"
            },
            Red = {
                Name = "Red Wisp",
                Desc = "The Red Wisp. Helps make your chao stronger. (Power +3)",
                isDecor = false,
                Value = "250"
            },
            Cyan = {
                Name = "Cyan Wisp",
                Desc = "The Cyan Wisp. Helps your chao swim better. (Swim +3)",
                isDecor = false,
                Value = "250"
            },
            Green = {
                Name = "Green Hover",
                Desc = "The Green",
                isDecor = false,
                Value = "250"
            }
        },
        Animals = {
            Name = "Animals",
            Otter = {
                Name = "Otter",
                Desc = "The Otter Animal. Found thoughout stages. Helps make your chao better at swimming at the cost of its power skill. (Swimming +7) (Power -3)",
                isDecor = false,
                Value = "250"
            },
            Penguin = {
                Name = "Penguin",
                Desc = "The Penguin Animal. Found thoughout stages. Helps make your chao better at swimming at the cost of its power skill. (Swimming +7) (Power -3)",
                isDecor = false,
                Value = "250"
            },
            Seal = {
                Name = "Seal",
                Desc = "The Seal Animal. Found thoughout stages. Helps make your chao better at swimming at the cost of its power skill. (Swimming +7) (Power -3)",
                isDecor = false,
                Value = "250"
            },
            Condor = {
                Name = "Condor",
                Desc = "The Condor Animal. Found thoughout stages. Helps make your chao better at flying at the cost of its power skill. (Flying +7) (Power -3)",
                isDecor = false,
                Value = "250"
            },
            Parrot = {
                Name = "Parrot",
                Desc = "The Parrot Animal. Found thoughout stages. Helps make your chao better at flying at the cost of its power skill. (Flying +7) (Power -3)",
                isDecor = false,
                Value = "250"
            },
            Peacock = {
                Name = "Peacock",
                Desc = "The Peacock Animal. Found thoughout stages. Helps make your chao better at flying at the cost of its power skill. (Flying +7) (Power -3)",
                isDecor = false,
                Value = "250"
            },
            Cheatah = {
                Name = "Cheatah",
                Desc = "The Cheatah Animal. Found thoughout stages. Helps make your chao better at running at the cost of its swimming skill. (Run +7) (Swim -3)",
                isDecor = false,
                Value = "250"
            },
            Boar = {
                Name = "Boar",
                Desc = "The Boar Animal. Found thoughout stages. Helps make your chao better at running at the cost of its swimming skill. (Run +7) (Swim -3)",
                isDecor = false,
                Value = "250"
            },
            Rabbit = {
                Name = "Rabbit",
                Desc = "The Rabbit Animal. Found thoughout stages. Helps make your chao better at running at the cost of its swimming skill. (Run +7) (Swim -3)",
                isDecor = false,
                Value = "250"
            },
            Bear = {
                Name = "Bear",
                Desc = "The Bear Animal. Found thoughout stages. Helps make your chao better at stronger at the cost of its swimming skill. (Power +7) (Flying -3)",
                isDecor = false,
                Value = "250"
            },
            Gorrilla = {
                Name = "Monke",
                Desc = "The Gorrilla Animal. Found thoughout stages. Helps make your chao stronger at the cost of its flying skill. (Power +7) (Flying -3)",
                isDecor = false,
                Value = "250"
            },
            Tiger = {
                Name = "Tiger",
                Desc = "The Tiger Animal. Found thoughout stages. Helps make your chao stronger at the cost of its flying skill. (Power +7) (Flying -3)",
                isDecor = false,
                Value = "250"
            },
        },
        ChaoDrives = {
            Name = "ChaoDrive",
            Run = {
                Name = "RunDrive",
                Desc = "The run chao drive. Increases your chao's running skill. Effectiveness depends on Chao's rank in running.",
                isDecor = false,
                Value = "-1"
            },
            Fly = {
                Name = "FlyDrive",
                Desc = "The fly chao drive. Increases your chao's flying skill. Effectiveness depends on Chao's rank in flying.",
                isDecor = false,
                Value = "-1"
            },
            Swim = {
                Name = "SwimDrive",
                Desc = "The swim chao drive. Increases your chao's swimming skill. Effectiveness depends on Chao's rank in swimming.",
                isDecor = false,
                Value = "-1"
            },
            Power = {
                Name = "PowerDrive",
                Desc = "The power chao drive. Increases your chao's power skill. Effectiveness depends on Chao's rank in power.",
                isDecor = false,
                Value = "-1"
            },
        },
    },
    Medals = {
        Name = "Medals"
    }
}

return tree</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="7">
        <Properties>
          <string name="Name">MarketData</string>
          <string name="Source">--[[
	MarketData
	Simular class but this table is specifically used for the the market.
]]

market = {
	Fruit = {
		Name = "Chao Fruit",
		isDecor = false,
		Price = "100",
		forSale = true,
		desc = "A tasty fruit all chao know and love,",
	},
	SFruit = {
		Name = "Square Fruit",
		desc = "A square shaped fruit. Some chao love this.",
		isDecor = false,
		Price = "100",
		forSale = true
	},
	RFruit = {
		Name = "Round Fruit",
		desc = "A round shaped fruit. Some chao love this.",
		isDecor = false,
		Price = "125",
		forSale = true
	},
	TFruit = {
		Name = "Triangle Fruit",
		desc = "A triangle shaped fruit. Some chao love this.",
		isDecor = false,
		Price = "150",
		forSale = true
	},
	StFruit = {
		Name = "Strong Fruit",
		desc = "Help your chao grow stronger. (Power +4)",
		isDecor = false,
		Price = "200",
		forSale = false
	},
	TaFruit = {
		Name = "Tasty Fruit",
		desc = "A tasty fruit that all chao love. Its great for their health too.",
		isDecor = false,
		Price = "350",
		forSale = false
	},
	HFruit = {
		Name = "Heart Fruit",
		desc = "A sweet tasting fruit that gets chao ready to mate.",
		isDecor = false,
		Price = "500",
		forSale = false
	},
	SMFruit = {
		Name = "Smart Fruit",
		desc = "A fruit with riveting flavor that helps your chao learn.",
		isDecor = false,
		Price = "500",
		forSale = false
	},
	Mint = {
		Name = "Mint Candy",
		desc = "A lucky piece of candy sure to give your chao tons of energy. (Luck +25)",
		isDecor = false,
		Price = "800"
		forSale = false
	}
}

return market</string>
        </Properties>
      </Item>
      <Item class="Folder" referent="8">
        <Properties>
          <string name="Name">rawItems</string>
        </Properties>
        <Item class="Model" referent="9">
          <Properties>
            <string name="Name">FlyDrive</string>
          </Properties>
          <Item class="Folder" referent="10">
            <Properties>
              <string name="Name">Meshes</string>
            </Properties>
            <Item class="MeshPart" referent="11">
              <Properties>
                <string name="Name">Cone</string>
              </Properties>
              <Item class="Script" referent="12">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="13">
              <Properties>
                <string name="Name">Cylinder (15)</string>
              </Properties>
              <Item class="Script" referent="14">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="15">
              <Properties>
                <string name="Name">Cylinder.001 (7)</string>
              </Properties>
              <Item class="Script" referent="16">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Script" referent="17">
            <Properties>
              <string name="Name">PickScript</string>
              <string name="Source"><![CDATA[--Makes it so you can feed your chao Chao Drives
local wait = task.wait
--dependancies
local UIService = require(game.ReplicatedStorage.PublicDependancies.UIService)
UIService:GenerateContextMenu("Pick",script.Parent,Enum.KeyCode.E,Enum.KeyCode.ButtonX,"Pick up your chao.")
UIService.updateContextMenu(script.Parent.Pick,"Name","ChaoDrive")

while wait(1) do
	local pickupStatus = UIService:GetContextMenuProperty(script.Parent.Pickup,"Context")
	if script.Parent.Held.Value == false then
		if pickupStatus ~= "Pick" then
			UIService.updateContextMenu(script.Parent.Pickup,"Context","Pick")
			UIService.updateContextMenu(script.Parent.Pickup,"ObjectText","Pick up the chaos drive.")
		end
	else
		if script.Parent.Parent:FindFirstChild("HumanoidRootPart") then
			if pickupStatus ~= "Drop" then
				UIService.updateContextMenu(script.Parent.Pickup,"Context","Drop")
				UIService.updateContextMenu(script.Parent.Pickup,"ObjectText","Place the chaos drive down.")				
			end
		end
	end
end

]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="Model" referent="18">
          <Properties>
            <string name="Name">PowerDrive</string>
          </Properties>
          <Item class="Folder" referent="19">
            <Properties>
              <string name="Name">Meshes</string>
            </Properties>
            <Item class="MeshPart" referent="20">
              <Properties>
                <string name="Name">Cone</string>
              </Properties>
              <Item class="Script" referent="21">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="22">
              <Properties>
                <string name="Name">Cylinder (15)</string>
              </Properties>
              <Item class="Script" referent="23">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="24">
              <Properties>
                <string name="Name">Cylinder.001 (7)</string>
              </Properties>
              <Item class="Script" referent="25">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Script" referent="26">
            <Properties>
              <string name="Name">PickScript</string>
              <string name="Source">--Makes it so you can feed your chao Chao Drives
local wait = task.wait
--dependancies
local UIService = require(game.ReplicatedStorage.PublicDependancies.UIService)
UIService:GenerateContextMenu("Pick",script.Parent,Enum.KeyCode.E,Enum.KeyCode.ButtonX,"Pick up your chao.")
UIService.updateContextMenu(script.Parent.Pick,"Name","ChaoDrive")

while wait(1) do
	local pickupStatus = UIService:GetContextMenuProperty(script.Parent.Pickup,"Context")
	if script.Parent.Held.Value == false then
		if pickupStatus ~= "Pick" then
			UIService.updateContextMenu(script.Parent.Pickup,"Context","Pick")
			UIService.updateContextMenu(script.Parent.Pickup,"ObjectText","Pick up the chaos drive.")
		end
	else
		if script.Parent.Parent:FindFirstChild("HumanoidRootPart") then
			if pickupStatus ~= "Drop" then
				UIService.updateContextMenu(script.Parent.Pickup,"Context","Drop")
				UIService.updateContextMenu(script.Parent.Pickup,"ObjectText","Place the chaos drive down.")				
			end
		end
	end
end</string>
            </Properties>
          </Item>
        </Item>
        <Item class="Model" referent="27">
          <Properties>
            <string name="Name">RunDrive</string>
          </Properties>
          <Item class="Folder" referent="28">
            <Properties>
              <string name="Name">Meshes</string>
            </Properties>
            <Item class="MeshPart" referent="29">
              <Properties>
                <string name="Name">Cone</string>
              </Properties>
              <Item class="Script" referent="30">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="31">
              <Properties>
                <string name="Name">Cylinder (15)</string>
              </Properties>
              <Item class="Script" referent="32">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="33">
              <Properties>
                <string name="Name">Cylinder.001 (7)</string>
              </Properties>
              <Item class="Script" referent="34">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Script" referent="35">
            <Properties>
              <string name="Name">PickScript</string>
              <string name="Source">--Makes it so you can feed your chao Chao Drives
local wait = task.wait
--dependancies
local UIService = require(game.ReplicatedStorage.PublicDependancies.UIService)
UIService:GenerateContextMenu("Pick",script.Parent,Enum.KeyCode.E,Enum.KeyCode.ButtonX,"Pick up your chao.")
UIService.updateContextMenu(script.Parent.Pick,"Name","ChaoDrive")

while wait(1) do
	local pickupStatus = UIService:GetContextMenuProperty(script.Parent.Pickup,"Context")
	if script.Parent.Held.Value == false then
		if pickupStatus ~= "Pick" then
			UIService.updateContextMenu(script.Parent.Pickup,"Context","Pick")
			UIService.updateContextMenu(script.Parent.Pickup,"ObjectText","Pick up the chaos drive.")
		end
	else
		if script.Parent.Parent:FindFirstChild("HumanoidRootPart") then
			if pickupStatus ~= "Drop" then
				UIService.updateContextMenu(script.Parent.Pickup,"Context","Drop")
				UIService.updateContextMenu(script.Parent.Pickup,"ObjectText","Place the chaos drive down.")				
			end
		end
	end
end</string>
            </Properties>
          </Item>
        </Item>
        <Item class="Model" referent="36">
          <Properties>
            <string name="Name">SwimDrive</string>
          </Properties>
          <Item class="Folder" referent="37">
            <Properties>
              <string name="Name">Meshes</string>
            </Properties>
            <Item class="MeshPart" referent="38">
              <Properties>
                <string name="Name">Cone</string>
              </Properties>
              <Item class="Script" referent="39">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="40">
              <Properties>
                <string name="Name">Cylinder (15)</string>
              </Properties>
              <Item class="Script" referent="41">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="42">
              <Properties>
                <string name="Name">Cylinder.001 (7)</string>
              </Properties>
              <Item class="Script" referent="43">
                <Properties>
                  <string name="Name">Float</string>
                  <string name="Source"><![CDATA[while true do
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, -0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end 
	wait(0.1)
	for i = 1,25,1 do
		script.Parent.CFrame = script.Parent.CFrame * CFrame.new(0, 0.01, 0)
		wait()
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Script" referent="44">
            <Properties>
              <string name="Name">PickScript</string>
              <string name="Source">--Makes it so you can feed your chao Chao Drives
local wait = task.wait
--dependancies
local UIService = require(game.ReplicatedStorage.PublicDependancies.UIService)
UIService:GenerateContextMenu("Pick",script.Parent,Enum.KeyCode.E,Enum.KeyCode.ButtonX,"Pick up your chao.")
UIService.updateContextMenu(script.Parent.Pick,"Name","ChaoDrive")

while wait(1) do
	local pickupStatus = UIService:GetContextMenuProperty(script.Parent.Pickup,"Context")
	if script.Parent.Held.Value == false then
		if pickupStatus ~= "Pick" then
			UIService.updateContextMenu(script.Parent.Pickup,"Context","Pick")
			UIService.updateContextMenu(script.Parent.Pickup,"ObjectText","Pick up the chaos drive.")
		end
	else
		if script.Parent.Parent:FindFirstChild("HumanoidRootPart") then
			if pickupStatus ~= "Drop" then
				UIService.updateContextMenu(script.Parent.Pickup,"Context","Drop")
				UIService.updateContextMenu(script.Parent.Pickup,"ObjectText","Place the chaos drive down.")				
			end
		end
	end
end</string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
    <Item class="Folder" referent="45">
      <Properties>
        <string name="Name">PublicDependancies</string>
      </Properties>
      <Item class="ModuleScript" referent="46">
        <Properties>
          <string name="Name">ChaoModule</string>
          <string name="Source">--[[
	ChaoModule
	The main module for the garden. Handles stats
]]

print("Alive!")
math.randomseed(tick())

local repl = game.ReplicatedStorage
local visualService = require(script.Parent.VisualService)
local Datastore = game:GetService("DataStoreService")
local saveData = Datastore:GetDataStore("Sonic Earth Chao Garden Alpha")
local module = {}

--Moved out of the createChao function since we need this in the rebirth.
local personalityTable = {
	--Adding more in the future.
	"Gentle",
	"Naughty",
	"Energetic",
	"Quiet",
	"Big Eater",
	"Chatty",
	"Easily Bored",
	"Curious",
	"Carefree",
	"Careless",
	"Smart",
	"Cry Baby",
	"Lonely",
	"Naive"
}

--Table that handles traits
--Contains the headTexture as Id
local traitLoadout = {
	RedMono = {
		Id = "",
		Dom = 50
	},
	RedTwo = {
		Id = "",
		Dom = 65
	},
	OrangeMono = {
		Id = "",
		Dom = 45
	},
	OrangeTwo = {
		Id = "",
		Dom = 24
	},
	YellowMono = {
		Id = "",
		Dom = 70
	},
	YellowTwo = {
		Id = "",
		Dom = 30
	},
	GreenMono = {
		Id = "",
		Dom = 65
	},
	GreenTwo = {
		Id = "",
		Dom = 54
	},
	BlueMono = {
		Id = "",
		Dom = 75
	},
	BlueTwo = {
		Id = "",
		Dom = 51
	},
	SkyBlueMono = {
		Id = "",
		Dom = 80
	},
	SkyBlueTwo = {
		Id = "",
		Dom = 68
	},
	LimeMono = {
		Id = "",
		Dom = 40
	},
	LimeTwo = {
		Id = "",
		Dom = 35
	},
	PurpleMono = {
		Id = "",
		Dom = 25
	},
	PurpleTwo = {
		Id = "",
		Dom = 15
	},
	BrownMono = {
		Id = "",
		Dom = 10
	},
	BrownTwo = {
		Id = "",
		Dom = 9
	},
	GreyMono = {
		Id = "",
		Dom = 5
	},
	GreyTwo = {
		Id = "",
		Dom = 4
	},
	BlackMono = {
		Id = "",
		Dom = 17
	},
	BlackTwo = {
		Id = "",
		Dom = 20
	},
	WhiteMono = {
		Id = "",
		Dom = 90
	},
	WhiteTwo = {
		Id = "",
		Dom = 2
	}
}

function module:Export(chaoData,chao)
	--Format the save data to a file that can be transfered to ChaoLink.
	print("Ready.")
	local chaostring = ""
	--Store stats
	chaostring = chaostring.."ARx"..chaoData.SwimRank.Value..";"
	chaostring = chaostring.."BRx"..chaoData.FlyRank.Value..";"
	chaostring = chaostring.."CRx"..chaoData.RunRank.Value..";"
	chaostring = chaostring.."DRx"..chaoData.PowerRank.Value..";"
	chaostring = chaostring.."FRx"..chaoData.StaminaRank.Value..";"
	--TODO: Support intelligence and luck stats
	chaostring = chaostring.."ALxt"..chaoData.SwimXP.Value..";"
	chaostring = chaostring.."BLxt"..chaoData.FlyXP.Value..";"
	chaostring = chaostring.."CLxt"..chaoData.RunXP.Value..";"
	chaostring = chaostring.."DLxt"..chaoData.PowerXP.Value..";"
	chaostring = chaostring.."FLxt"..chaoData.StaminaXP.Value..";"
	--TODO: Support intelligence and luck stats
	chaostring = chaostring.."ALx"..chaoData.SwimLevel.Value..";"
	chaostring = chaostring.."BLx"..chaoData.FlyLevel.Value..";"
	chaostring = chaostring.."CLx"..chaoData.RunLevel.Value..";"
	chaostring = chaostring.."DLx"..chaoData.PowerLevel.Value..";"
	chaostring = chaostring.."FLx"..chaoData.StaminaLevel.Value..";"
	--Store color data
	--TODO: Support shiny and jewel chao
	local tone = visualService:returnTone(chao)
	if tone == "mono" then
		chaostring = chaostring.."iTSxF;"
	else
		chaostring = chaostring.."iTSxT;"
	end
	--Store chao types
	if chaoData.Ability.Value == "Hero" then
		chaostring = chaostring.."alRxH;"
	elseif chaoData.Ability.Value == "Dark" then
		chaostring = chaostring.."alRxD;"
	elseif chaoData.Ability.Value == "Normal" then
		chaostring = chaostring.."alRxN"
	else
		chaostring = chaostring.."alRxC"
	end
	if chaoData.Attribute.Value == "Swim" then
		chaostring = chaostring.."TRxA"
	elseif chaoData.Attribute.Value == "Fly" then
		chaostring = chaostring.."TRxB"
	elseif chaoData.Attribute.Value == "Run" then
		chaostring = chaostring.."TRxC"
	elseif chaoData.Attribute.Value == "Power" then
		chaostring = chaostring.."TRxD"
	elseif chaoData.Attribute.Value == "Stamina" then
		chaostring = chaostring.."TRxF"
	end
	--TODO: Support Chaos Chao
	chaostring = chaostring.."CCSxF"
	--TODO: Support Second Evolutions
	--Store Name
	chaostring = chaostring.."Namex"..chaoData.ChaoName.Value
	--Store Personality
	local person
	for i,v in pairs(personalityTable) do
		if v == chaoData.Personality.Value then
			person = i
		break
		else end
	end
	chaostring = chaostring.."PTRx"..person..";"
	--Store static variables
	chaostring = chaostring.."HzSX"..chaoData.Hunger.Value
	chaostring = chaostring.."TzSx"..chaoData.Tiredness.Value
	chaostring = chaostring.."CzSx"..chaoData.Condition.Value
	chaostring = chaostring.."HHSx"..chaoData.Happiness.Value
	chaostring = chaostring.."AzSX"..chaoData.Age.value
	--TODO: Support a Daycare system
	--chaostring = chaostring.."OzSX"..player.UserId
	return chaostring
end

--Change any data
function module.changeData(stat,value,chaoData)
	if chaoData then
		if stat and value then
			local data = chaoData:FindFirstChild(stat)
			if data then
				local isNumber = tonumber(value)
				if isNumber then
					chaoData[stat].Value += value
				else 
					chaoData[stat].Value = value
				end
			else
				warn("Data doesn't exist")
			end
		end
	else
		warn("Invalid ChaoData")
	end
end

--Level up on core stats
function module.changeStat(stat,value,chaoData)
	if chaoData then
		if stat and value then
			if stat == "Run" then
				local mx = chaoData.RunRank.Value
				local trueValue = value*mx
				chaoData.RunXP.Value += trueValue
				if chaoData.RunXP.Value >= chaoData.RunLevel.Value * 100 and chaoData.RunLevel.Value ~= 99 then
					chaoData.RunLevel.Value += 1
				end
			end
			if stat == "Power" then
				local mx = chaoData.PowerRank.Value
				local trueValue = value*mx
				chaoData.PowerXP.Value += trueValue
				if chaoData.PowerXP.Value >= chaoData.PowerLevel.Value * 100 and chaoData.PowerLevel.Value ~= 99 then
					chaoData.PowerLevel.Value += 1
				end
			end
			if stat == "Swim" then
				local mx = chaoData.SwimRank.Value
				local trueValue = value*mx
				chaoData.SwimXP.Value += trueValue
				if chaoData.SwimXP.Value >= chaoData.SwimLevel.Value * 100 and chaoData.SwimLevel.Value ~= 99 then
					chaoData.SwimLevel.Value += 1
				end
			end
			if stat == "Fly" then
				local mx = chaoData.FlyRank.Value
				local trueValue = value*mx
				chaoData.FlyXP.Value += trueValue
				if chaoData.FlyXP.Value >= chaoData.FlyLevel.Value * 100 and chaoData.FlyLevel.Value ~= 99 then
					chaoData.FlyLevel.Value += 1
				end
			end
			if stat == "Stamina" then
				local mx = chaoData.StaminaRank.Value
				local trueValue = value*mx
				chaoData.StaminaXP.Value += trueValue
				if chaoData.StaminaXP.Value >= chaoData.StaminaLevel.Value * 100 and chaoData.StaminaLevel.Value ~= 99 then
					chaoData.StaminaLevel.Value += 1
				end
			end
		end
	else
		warn("Invalid ChaoData")
	end
end

--Create a chao
function module.newChao()
	print("Ready!")
	--generate stats
	local folder = game.ReplicatedStorage.Folder
	local rng = math.random(5)
	local statTable = {
		1,
		1,
		1,
		1,
		1
	}
	--fills the stats table and makes it so only one stat can be an A. This isn't for the genepool.
	local hasfive = false
	for i,v in pairs(statTable) do
		if not hasfive then
			local rng = math.random(5)
			statTable[i] = rng
			if rng == 5 then
				hasfive = true
			end
		else
			statTable[i] = math.random(4)
		end
	end
	folder.SwimRank.Value = statTable[1]
	folder.FlyRank.Value = statTable[2]
	folder.RunRank.Value = statTable[3]
	folder.PowerRank.Value = statTable[4]
	folder.StaminaRank.Value = statTable[5]
	folder.Age.Value = 0
	folder.Class.Value = 0
	folder.Attribute.Value = "Child"
	folder.Condition.Value = "none"
	folder.Happiness.Value = 50
	folder.Hunger.Value = 1
	local trng = math.random(#personalityTable)
	folder.Personality.Value = personalityTable[trng]
	--Here we randomize the position of the chao. I'll do that later on
	folder.Hatched.Value = false
	print("Done. New Chao Data made.")
	return folder
end

--Spawn a chao
function module.spawnChao(chao) --chaoData
	if chao.Hatched.Value == true then
		--spawn a chao
		local copy = repl.baseChao:Clone()
		copy.Parent = workspace
		copy.HumanoidRootPart.Position = Vector3.new(10,0,10) --TODO: Randomize this
	else
		--spawn a chao egg
		local copy = repl.Egg:Clone()
		copy.Parent = workspace
		copy.Position = Vector3.new(170.047, 171.708, 256.577) --TODO: Randomize this
	end
end

--hatch a chao egg
function module.Hatch(Egg,baseChao)
	if Egg then
		if baseChao then
			local hatchedEgg = repl.Broken_Egg:Clone()
			local goalPos = Egg.Position
			print(tostring(goalPos))
			hatchedEgg.Parent = workspace
			hatchedEgg:MoveTo(goalPos)
			Egg:Destroy()
			wait(3)
			local copy
			for i,v in pairs(repl.chaoStore:GetDescendants()) do
				if v:IsA("StringValue") then
					if v.Value == Egg.Identifier.Value then
						copy = v.Parent
					end
				end
			end
			copy.Parent = workspace
			copy.HumanoidRootPart.Position = goalPos
		else
			local hatchedEgg = repl.Broken_Egg:Clone()
			local goalPos = Egg.Position
			print(tostring(goalPos))
			hatchedEgg.Parent = workspace
			hatchedEgg:MoveTo(goalPos)
			Egg:Destroy()
			wait(3)
			local copy = repl.baseChao:Clone()
			copy.Parent = workspace
			copy.HumanoidRootPart.Position = goalPos
		end
	else
		warn("No Egg to Hatch!")
	end
end

--Return a stat
function module:GetStats(ChaoData,player, stat)
	if player and stat then
		if player:FindFirstChild(ChaoData) then
			if player.ChaoData[ChaoData]:FindFirstChild(stat) then
				return player.ChaoData[ChaoData][stat].Value
			end
		end
	end
end

--Chao Evolution
function module:Evo(chaoData,chao,player)
	if player and chao then
		--Prevent the chao from Aging while evolving
		chaoData.canAge = false
		--Change ChaoState to sitting and play anim

		--Create Chao Cocoon
		local cocoon --Path to chao cocoon.
		cocoon:Clone()
		coccon.Parent = workspace
		cocoon.Position  = chao.HumanoidRootPart.Position

		--Determine Ability Evolution
		local chaoType
		if chaoData.AbilityDirection.Value >= 0.5 then
			chaoType = "Hero"
		elseif chaoData.AbilityDirection.Value &lt;= -0.5 then
			chaoType = "Dark"
		else
			chaoType = "Normal"
		end 
		--Apply Visual Changes
		visualService:ChangeHeadType(chao,chaoType)
		--Apply SaveData Changes
		chaoData.Ability.Value = chaoType
		--Determine Type Evolution
		if chaoData.LastUpgraded == "Swim" then
			chaoType = "Swim"
		elseif chaoData.LastUpgraded == "Fly" then
			chaoType = "Fly"
		elseif chaoData.LastUpgraded == "Run" then
			chaoType = "Run"
		elseif chaoData.LastUpgraded == "Power" then
			chaoType = "Power"
		end
		--Apply Visual Changes
		visualService:ChangeChaoType(chao,chaoType)
		--Apply SaveData Changes
		chaoData.Attribute.Value = chaoType
		--Remove Cocoon
		for count = 1,100 do
			cocoon.Transparency -= 0.01
		end
		cocoon:Destroy()
		--Clean up
		chaoData.canAge = true
	end
end

--Chao Reincarnation
function module:Rebirth(chaoData,chao,player)
	if player and chao then
		--Prevent the chao from Aging while evolving
		chaoData.canAge = false
		--Change ChaoState to sitting and play anim

		--Create Pink Cocoon
		local cocoon --Path to chao cocoon.
		cocoon:Clone()
		coccon.Parent = workspace
		cocoon.Position  = chao.HumanoidRootPart.Position
		--Reset every stat to 10 percent of its current value
		chaoData.FlyXP.Value = math.floor(chaoData.FlyXP.Value*10/100)
		chaoData.SwimXP.Value = math.floor(chaoData.SwimXP.Value*10/100)
		chaoData.RunXP.Value = math.floor(chaoData.RunXP.Value*10/100)
		chaoData.PowerXP.Value = math.floor(chaoData.PowerXP.Value*10/100)
		chaoData.StaminaXP.Value = math.floor(chaoData.StaminaXP.Value*10/100)
		--Reset personaility
		local prng = math.random(#personalityTable)
		chaoData.Personality.Value = personalityTable[prng]
		--Reset Age
		chaoData.Age.Value = 0
		--Reset attribute and ablility
		chaoData.Attribute.Value = "Child"
		chaoData.AbilityDirection = 0
		chaoData.Ability.Value = ""
		--Remove Cocoon
		for count = 1,100 do
			cocoon.Transparency -= 0.01
		end
		cocoon:Destroy()
		--Clean up
		chaoData.canAge = true
	end
end

--Chao Death
function module:RemoveChao(chaoData,chao,player)
	if chaoData and chao then
		--Prevent the chao from Aging while evolving
		chaoData.canAge = false
		--Change ChaoState to sitting and play anim

		--Create White Cocoon
		local cocoon --Path to chao cocoon.
		cocoon:Clone()
		coccon.Parent = workspace
		cocoon.Position  = chao.HumanoidRootPart.Position
		--Destroy ChaoData
		local wasInterupted = false
		for i,v in pairs(chaoData:GetChildren()) do
			local success, response = pcall(function(v)
				local save_data = saveData:GetAsync("User_"..player.UserId)
				save_data.Data[v] = nil
				saveData:SetAsync("User_"..player.UserId,save_data)
			end)
			if not success then
				print(response)
				wasInterupted = true
				break
			else end
		end
		--destroy the folder itself
		if wasInterupted == false then --ensure the data actually got deleted
			chaoData:Destroy()
		end
		--remove chao
		chao:Destroy()
		--Remove Cocoon
		for count = 1,100 do
			cocoon.Transparency -= 0.01
		end
		cocoon:Destroy()
	end
end

--Handle Breeding chao stats
function module:BreedChao(chaoData1,chaoData2,chao1,chao2)
	--Determine what stats to take from who
	local chao1Stats = {}
	chao1Stats[1] = chaoData1.FlyXP.Value
	chao1Stats[2] = chaoData1.SwimXP.Value
	chao1Stats[3] = chaoData1.RunXP.Value
	chao1Stats[4] = chaoData1.PowerXP.Value
	chao1Stats[5] = chaoData1.StaminaXP.Value
	local chao2Stats = {}
	chao2Stats[1] = chaoData2.FlyXP.Value
	chao2Stats[2] = chaoData2.SwimXP.Value
	chao2Stats[3] = chaoData2.RunXP.Value
	chao2Stats[4] = chaoData2.PowerXP.Value
	chao2Stats[5] = chaoData2.StaminaXP.Value
	local newChaoStats = {}
	for count = 1,5 do
		local rand = math.random(2)
		if rand == 1 then
			newChaoStats[count] = chao1Stats[count]
		elseif rand == 2 then
			newChaoStats[count] = chao2Stats[count]
		end
	end
	--Decide the chao's color and color it with visual service
	local newChao = repl.baseChao:Clone()
	local color
	local isTwoTone
	--Basic Chao Punett Sqaure
	local chao1Color = chao1.Head.HeadMesh.Id
	local chao2Color = chao2.Head.HeadMesh.Id
	local compare1
	local compare2
	for i,v in pairs(traitLoadout) do
		if v.Id == chao1Color then
			compare1 = v.Dom
		elseif v.Id == chao2Color then
			compare2 = v.Dom
		end
	end
	if compare1 > compare2 then
		color = visualService:returnColor(chao1)
	elseif compare2 > compare1 then
		color = visualService:returnColor(chao2)
	end
	--Color chao with correct alleles
	visualService:ColorChao(newChao,color,isTwoTone)
	--add the newChao to cache
	newChao.Parent = game.ReplicatedStorage.chaoStore
	--add a few tags to link the chao to the egg.
	local vEx = Instance.new("StringValue")
	vEx.Name = "Identifier"
	vEx.Value = chao1.Name.."-"..chao2.Name
	local newEgg = repl.Egg:Clone()
	local tagCopy = vEx:Clone()
	tagCopy.Parent = newEgg
	tagCopy.Position = chao1.Position
	newEgg.Parent = workspace
end

return module</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="47">
        <Properties>
          <string name="Name">ClassService</string>
          <string name="Source">--[[
    ClassService
    The Module that uses the ClassTree and makes it usable by other scripts
]]

local service = {}

local items = require(game.ReplicatedStorage.MarketPlace.Class)
local rawItems = game.ReplicatedStorage.MarketPlace.rawItems

--table.find alternative
function service.GetArrayItem(array,item)
    for i,v in pairs(array) do
        if v.Name == item then
            return v
        else end
    return false
    end
end

--Clone and object and return it
function service:GetItem(item)
    local itemExist = service.GetArrayItem(items,item)
    if itemExist then
        if rawItems:FindFirstChild(item) then
            local myItem = rawItems[item]:Clone()
            return myItem
        end
    else
        return nil
    end
end

--Return the description of an item
function service:GetItemInfo(class,item)
    local classExist = service.GetArrayItem(items,class)
    if classExist then
        local itemExist = service.GetArrayItem(items[class],item)
        if itemExist then
            return items[class][item].Desc
        else
            return nil
        end
    else
        return "Invalid Class"
    end
end

--Return all members of a class
function service:GetChildrenOfClass(class)
    local classExist = service.GetArrayItem(items,class)
    if classExist then
        return items[class]
    else
        return "Invalid Class"
    end
end

--Return an items stats (such as isDecor)
function service:GetItemDetails(class,item)
    local classExist = service.GetArrayItem(items,class)
    if classExist then
        local itemExist = service.GetArrayItem(items[class],item)
        if itemExist then
            return items[class][item]
        end
    else
        return "Invalid Class"
    end
end

--Returns the class an item belongs to.
function service:GetItemsClass(item)
    local class
    if service.GetArrayItem(items.Chao,item) then
        class = "Chao"
    elseif service.GetArrayItem(items.Food,item) then
        class = "Food"
    elseif service.GetArrayItem(items.Animals,item) then
        class = "Animals"
    elseif service.GetArrayItem(items.Toys) then
        class = "Toys"
    elseif service.GetArrayItem(items.Medals,item) then
        class = "Medals"
    else
        class = nil
    end
    return class
end

return service</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="48">
        <Properties>
          <string name="Name">Classroom</string>
          <string name="Source">local service = {}

local current = script.Parent.currentClass

local lessons = {
    "Song",
    "Shake Dance",
    "Drawing",
    "Bell",
    "Drum",
    "Song",
    "Spin Dance",
    "Tambourine",
    "Drawing",
    "Trumpet",
}

function service:GetCurrentLesson()
    return current
end

function service:ChangeClass(currentClass)
    local lastClass = lessons[current]
    local newClass = lastClass += 1
    current.Value = newClass 
end

function service:LearnLesson(chaoData)
    chaoData.InProgressLesson.Value = current
    chaoData.LessonStartTime.Value = os.time()
end

function service:IsLessonDone(chaoData)
    local finishTime = LessonStartTime + 14400
    if os.time > finishTime then
        return "Done"
    else
        return "Incomplete"
    end
end

return service</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="49">
        <Properties>
          <string name="Name">MarketService</string>
          <string name="Source">--[[
	MaketService
	Handles the Chao Black Market
]]

local service = {}

local wait = task.wait
local market = require(game.ReplicatedStorage.MarketPlace.MarketData)
local class = require(game.ReplicatedStorage.PublicDependancies.ClassService)

function service.GetArrayItem(array,item)
    for i,v in pairs(array) do
        if v.Name == item then
            return v
        else end
    return false
    end
end

function service:Initialize(plr)
	--Initialize the system
	warn("This system is experimental. It does not save any data at all. Make sure you use everything as you will lose it upon leaving the game.")
	if workspace:FindFirstChild(tostring(plr.Name.." Inventory")) then
		warn("This player's data already exist. Overwriting with a new folder...")
		workspace[plr.Name.." Inventory"]:Destroy()
	else
		print("Writing new folder for player")
	end
	local folder = Instance.new("Folder", workspace)
	folder.Name = tostring(plr.Name.." Inventory")
end

function service:LoadMarket(frame,template)
	--loop through the marketplace and add all for sale items to the ui
	if frame and template then
		for i,v in pairs(market) do
			local copy = template:Clone()
			copy.Name = v.Name
			copy.NameBox.Text = v.Name
			copy.Desc.Text = v.desc
			-- TODO: Use UI Service to make a viewport frame.
			copy.Parent = frame
		end
	else
		return "Build Error."
	end
end

function service:getItemDesc(item)
	--Get the description of items.
	local itemExist = service.GetArrayItem(market,item)
	if itemExist then
		return market[item].desc
	else
		return nil
	end
end

--Create the Inventory UI
function getInventory(plr,frame,template)
	if plr then
		if workspace:FindFirstChild(tostring(plr.Name.." Inventory")) then
			for i,v in pairs(workspace[plr.Name.." Inventory"]:GetChildren()) do
				if v:FindFirstChild("className") then
					print(v.Name)
					if frame and template then
						local copy = template:Clone()
						copy.Name = v.Name
						copy.NameBox.Text = v.Name
						copy.Desc.Text = v.desc
						copy.Parent = frame
					end
				end
			end
		end
	else
		warn("No player found.")
	end
end

function service:PurchaseItem(item,plr)
	--Purchase the item and add it to the inventory folder.
	local itemExist = service.GetArrayItem(market,item)
	if item and plr and itemExist then
		local money = plr.ChaoStats.Rings -->Use a temporary ring system now 
		if money and money.Value >=  item.Price then
			money.Value -= item.Price
			local myItem = class:GetItem(item)
			myItem.Parent = workspace[plr.Name.." Inventory"]
		end
	else
		warn("PurchaseItem run error. Item: "..item.."plr "..plr.Name)
	end
end

function service:SellItem(item,plr)
	--Sell an item for 70% of its origin value.
	local itemExist = service.GetArrayItem(market,item)
	if itemExist then
		local salePrice = (market[item].Price * 70)/100
		local money = plr.ChaoStats.Rings
		money.Value += salePrice
		if workspace[plr.Name.." Inventory"]:FindFirstChild(item.Name) then
			--Delete the item when they sell it.
			workspace[plr.Name.." Inventory"][item.Name]:Destroy()
			if salePrice >= 10000 then
				money.Value += 2500 -- A small bonus for selling an expensive item
			end
		end
	end
end

return service</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="50">
        <Properties>
          <string name="Name">NameSpaceService</string>
          <string name="Source">--[[
    NameSpaceService
    Handles naming chao
]]

math.randomseed(tick())
local TS = game:GetService("TextService")

local module = {}

local Names = {
    "Ajax",
    "Atom",
    "Bingo",
    "Brandy",
    "Bruno",
    "Bubbles",
    "Buddy",
    "Buzzy",
    "Cash",
    "Casino",
    "Chacha",
    "Chacky",
    "Chaggy",
    "Chai",
    "Chalulu",
    "Cham",
    "Champ",
    "Chang",
    "Chaofun",
    "Chaoko",
    "Chaolin",
    "Chaorro",
    "Chaosky",
    "Chap",
    "Chapon",
    "Chappy",
    "Charon",
    "Chasm",
    "Chaz",
    "Cheng",
    "Choc",
    "Cholly",
    "Chucky",
    "Cody",
    "Cuckoo",
    "DEJIME",
    "Dash",
    "Dingy",
    "Dino",
    "Dixie",
    "Echo",
    "Edge",
    "Elvis",
    "Emmy",
    "Flamingo",
    "Fuzzie",
    "Groom",
    "HITM",
    "Hiya",
    "Honey",
    "Jojo",
    "Keno",
    "Kosmo",
    "Loose",
    "Melody",
    "NAGOSHI",
    "OVER",
    "Papoose",
    "Peaches",
    "Pebbles",
    "Pinky",
    "Quartz",
    "Quincy",
    "RUSSO",
    "Rascal",
    "Rocky",
    "Rover",
    "Roxy",
    "Rusty",
    "SMILEB",
    "SOUL",
    "Spike",
    "Star",
    "Tango",
    "Tiny",
    "WOW",
    "Woody",
    "YS",
    "Zack",
    "Zippy"
}

function module:GenerateName()
    local rng = math.random(#Names)
    return Names[rng]
end

function module:ModerateName(name,player)
    return TS:FilterStringAsync(name,player.UserId)
end

return module</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="51">
        <Properties>
          <string name="Name">UIService</string>
          <string name="Source"><![CDATA[--[[
	UIService
	Handles general UI operations like viewport frames and ContextMenus
]]

local module = {}

--Change Signals
local changeSignals = {
	"Context",
	"Input",
	"ConsoleInput",
	"ObjectText",
	"Name"
}

--Creates the ContextMenu
function module:GenerateContextMenu(context,obj,Input,cInput,objectText)
	if context and obj then
		local contextMenu = Instance.new("ProximityPrompt")
		contextMenu.Name = context
		contextMenu.ActionText = context
		if Input then
			contextMenu.KeyboardKeyCode = Input
		end
		if cInput then
			contextMenu.GamepadKeyCode = cInput
		end
		if objectText then
			contextMenu.ObjectText = objectText
		end
		contextMenu.MaxActivationDistance = 15
		contextMenu.Parent = obj
	else
		warn("Missing Inputs")
	end
end

--Allows you edit ContextMenu
function module:UpdateContextMenu(obj,changeSignal,ctx)
	if obj and obj:IsA("ProximityPrompt") then
		if table.find(changeSignals,changeSignal,1) then
			if changeSignal == "Context" then
				obj.ActionText = ctx
			end
			if  changeSignal == "Input" then
				obj.KeyboardKeyCode = ctx
			end
			if changeSignal == "ConsoleInput" then
				obj.GamepadKeyCode = ctx
			end
			if changeSignal == "ObjectText" then
				obj.ObjectText = ctx
			end
			if changeSignal == "Name" then
				obj.Name = ctx
			end
		else
			warn("Invalid Change Signal")
		end
	else
		warn("Attempted to update nil or invalid object.")
	end
end

--Delete the ContextMenu
function module:DestroyContextMenu(contextMenu)
	if contextMenu and contextMenu:IsA("ProximityPrompt") then
		contextMenu:Destroy()
		print("Destoyed Secessfully.")
	else
		warn("Attempted to destroy nil or invalid object")
	end
end

--Return the ContextMenu's Data
function module:GetContextMenuProperty(obj,property)
	if obj and obj:IsA("ProximityPrompt") then
		if table.find(changeSignals,property,1) then
			if property == "Context" then
				return obj.ActionText
			end
			if property == "Input" then
				return obj.KeyboardKeyCode
			end
			if property == "ConsoleInput" then
				return obj.GamepadKeyCode
			end
			if property == "ObjectText" then
				return obj.ObjectText
			end
			if property == "Name" then
				return obj.Name
			end
		end
	else
		warn("Unable to get proprties of nil or invalid object.")
	end
end

--Create Viewport Frame
function module:CreateChaoViewPort(chao, object, corner)
	if chao and chao:FindFirstChild("HumanoidRootPart") and object then
		local copyChao = chao:Clone()
		copyChao:MoveTo(Vector3.new(0,0,0))
		local id = Instance.new("StringValue", copyChao)
		id.Value = chao.Name
		id.Name = "Id"
		copyChao.Name = "TempChao"
		copyChao.Parent = workspace
		local frame = Instance.new("ViewportFrame")
		frame.AnchorPoint = UDim.new(0,0)
		frame.Size = UDim2.new(1,0,1,0)
		frame.Position = UDim2.new(0,0,0,0)
		frame.BackgroundTransparency = 1
		frame.Parent = object
		local cam = Instance.new("Camera")
		cam.Parent = frame
		print(cam.Parent.Name)
		cam.FieldOfView = 45
		frame.CurrentCamera = cam
		local humroot = chao:FindFirstChild("HumanoidRootPart")
		cam.CFrame = CFrame.new(Vector3.new(0,2,12), humroot.Position)
		if corner then
			local uicorner = Instance.new("UICorner")
			uicorner.CornerRadius = UDim.new(0,20)
			uicorner.Parent = object
		end
	end
end


return module
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="52">
        <Properties>
          <string name="Name">VisualService</string>
          <string name="Source">--[[
    VisualService
    A service used to changethe visual appearance of chao based on their stats
]]

local service = {}

--A Class Table for Emotion Ball Types
local headTypes = {
    Hero = {
        Name = "Hero",
        ID = ""
    },
    Dark = {
        Name = "Dark",
        ID = ""
    },
    Normal = {
        Name = "Normal",
        ID = ""
    },
}

local monoColors = {
    White = {
        Name = "White",
        ID = ""
    },
    Blue = {
        Name = "Blue",
        ID = ""
    },
    Red = {
        Name = "Red",
        ID = ""
    },
    Yellow = {
        Name = "Yellow",
        ID = ""
    },
    Orange = {
        Name = "Orange",
        ID = ""
    },
    Sky Blue = {
        Name = "Sky Blue",
        ID = ""
    },
    Pink = {
        Name = "Pink",
        ID = ""
    },
    Green = {
        Name = "Green",
        ID = ""
    },
    Brown = {
        Name = "Brown",
        ID = ""
    },
    Purple = {
        Name = "Purple",
        ID = ""
    },
    Grey = {
        Name = "Grey",
        ID = ""
    },
    Lime = {
        Name = "Lime",
        ID = ""
    },
    Black = {
        Name = "Black",
        ID = ""
    }
}

local twotoneColor = {
    White = {
        Name = "White",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
    Blue = {
        Name = "Blue",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
    Red = {
        Name = "Red",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
    Yellow = {
        Name = "Yellow",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
    Orange = {
        Name = "Orange",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
    Sky Blue = {
        Name = "Sky Blue",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
    Pink = {
        Name = "Pink",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
    Green = {
        Name = "Green",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
    Brown = {
        Name = "Brown",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
    Purple = {
        Name = "Purple",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
    Grey = {
        Name = "Grey",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
    Lime = {
        Name = "Lime",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
    Black = {
        Name = "Black",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
}

local jewels = {
    Gold = {
        Name = "Gold",
        ID = ""
    },
    Silver = {
        Name = "Silver",
        ID = ""
    },
    Emerald = {
        Name = "Emerald",
        ID = ""
    },
    Garnet = {
        Name = "Garnet",
        ID = ""
    },
    Amethyst = {
        Name = "Amethyst",
        ID = ""
    },
    Sapphire = {
        Name = "Sapphire",
        ID = ""
    },
    Peridot = {
        Name = "Peridot",
        ID = ""
    },
    Ruby = {
        Name = "Ruby",
        ID = ""
    },
    Topaz = {
        Name = "Topaz",
        ID = ""
    },
    Aquamarine = {
        Name = "Aquamarine",
        ID = ""
    },
    Onyx = {
        Name = "Onyx",
        ID = ""
    },
    Moon = {
        Name = "Moon",
        ID = ""
    }
}

local animalParts = {
    Otter = {
        Name = "Otter",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
    Penguin = {
        Name = "Penguin",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
    Seal = {
        Name = "Seal",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
    Condor = {
        Name = "Condor",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
    Parrot = {
        Name = "Parrot",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
    Peacock = {
        Name = "Peacock",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
    Cheetah = {
        Name = "Cheatah",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
    Boar = {
        Name = "Boar",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
    Rabbit = {
        Name = "Rabbit",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
    Bear = {
        Name = "Bear",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
    Gorilla = {
        Name = "Gorilla",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    },
    Tiger = {
        Name = "Tiger",
        Head = "",
        LeftArm = "",
        RightArm = "",
        Body = "",
        LLeg = "",
        RLeg = "",
        Tail = ""
    }
}

--Alternative table.find
function service.GetArrayItem(item,array)
    for i,v in pairs(array) do
        if v.Name == item then
            return v
        else end
    return false
    end
end

--Changes the emotion ball
function service:ChangeHeadType(chao,headType)
    if service.GetArrayItem(headTypes,headType)  then
        chao.Emotion.MeshPart.Mesh = service.GetArrayItem(headTypes,headType).ID
        print("HeadType Changed")
    else
        warn("Invalid HeadType")
    end
end

function service:returnTone(chao)
    local item = chao.Head.HeadMesh.Id
    for i,v in pairs(monoColors) do
        if v.Id == item then
            return "mono"
        end
    end
    for i,v in pairs(twotoneColor) do
        if v.Head == item then
            return "two"
        end
    end
end

function service:returnColor(chao)
    local item = chao.Head.HeadMesh.Id
    for i,v in pairs(monoColors) do
        if v.Id == item then
            return v.Name
        end
    end
    for i,v in pairs(twotoneColor) do
        if v.Head == item then
            return v.Name
        end
    end
end
--Changes parts of the chao to animal parts
function service:ChangeBodyPart(chao,part)
    if service.GetArrayItem(chao,part) then
    end
end

--Changes chao color
function service:ColorChao(chao,color,isTwoTone)
    if isTwoTone == false then
        if service.GetArrayItem(monoColors,color) then
            for i,v in pairs(chao:GetDescendants()) do
                if v:IsA("SpecialMesh") then
                    if not v.Name == "Eyes" then
                        v.TextureId = service.GetArrayItem(monoColors,color).ID
                        print("Changed Chao Part")
                    end
                end
            end
        end
    else
        if service.GetArrayItem(monoColors,color) then
            for i,v in pairs(chao:GetDescendants()) do
                if v:IsA("SpecialMesh") then
                    if not v.Name == "Eyes" then
                        if service.GetArrayItem(monoColors[color],v.Name) then
                            v.TextureId = service.GetArrayItem(monoColors,color)[v.Name]
                            print("Changed Chao Part")
                        end
                    end
                end
            end
        end
    end
end

--Colors Shiny or Jewel Chao
function service:ShineChao(chao,color,class)
    if class == "Jewel" then
        if service.GetArrayItem(jewels,color) then
            for i,v in pairs(chao:GetDescendants()) do
                if v:IsA("SpecialMesh") then
                    if not v.Name == "Eyes" then
                        v.TextureId = service.GetArrayItem(jewels,color).ID
                    end
                end
            end
        end
    elseif class == "Shiny" then
        if service.GetArrayItem(monoColors,color) then
            for i,v in pairs(chao:GetDescendants()) do
                if v:IsA("SpecialMesh") then
                    if not v.Name == "Eyes" then
                        v.TextureId = service.GetArrayItem(monoColors,color)[v.Name]
                        v.Material = Enum.Material.SmoothPlastic
                        v.Reflectance = 1
                        print("Shiny Chao Made")
                    end
                end
            end
        end
    end
end

return service</string>
        </Properties>
      </Item>
      <Item class="StringValue" referent="53">
        <Properties>
          <string name="Name">currentClass</string>
          <string name="Value">Song</string>
        </Properties>
      </Item>
    </Item>
    <Item class="Model" referent="54">
      <Properties>
        <string name="Name">baseChao</string>
      </Properties>
      <Item class="Part" referent="55">
        <Properties>
          <string name="Name">HumanoidRootPart</string>
        </Properties>
        <Item class="Script" referent="56">
          <Properties>
            <string name="Name">PickScript</string>
            <string name="Source">--Makes it so you can pick up your chao and throw it
local wait = task.wait
--dependancies
local UIService = require(game.ReplicatedStorage.PublicDependancies.UIService)
--Use UIService to create ContextMenues
UIService:GenerateContextMenu("Pick",script.Parent,Enum.KeyCode.E,Enum.KeyCode.ButtonX,"Pick up your chao.")
UIService:UpdateContextMenu(script.Parent.Pick,"Name","Pickup")
UIService:GenerateContextMenu("Pet",script.Parent,Enum.KeyCode.Q,Enum.KeyCode.ButtonY, "Pet Your Chao.")

while wait(1) do
	local pickupStatus = UIService:GetContextMenuProperty(script.Parent.Pickup,"Context")
	if script.Parent.Held.Value == false then
		if pickupStatus ~= "Pick" then
			UIService:UpdateContextMenu(script.Parent.Pickup,"Context","Pick")
			UIService:UpdateContextMenu(script.Parent.Pickup,"ObjectText","Pick up your chao.")
		end
	else
		if script.Parent.Parent:FindFirstChild("HumanoidRootPart") then
			local velo = script.Parent.Parent.HumanoidRootPart.Velocity.Magnitude
			print("Velocity: "..velo)--Actually print the velocity.
			if velo >= 2 then
				if pickupStatus ~= "Throw" then
					UIService:UpdateContextMenu(script.Parent.Pickup,"Context","Throw")
					UIService:UpdateContextMenu(script.Parent.Pickup,"ObjectText","Throw your chao.")				
				end
			else
				if pickupStatus ~= "Drop" then
					UIService:UpdateContextMenu(script.Parent.Pickup,"Context","Drop")
					UIService:UpdateContextMenu(script.Parent.Pickup,"ObjectText","Place your chao down.")				
				end
			end
		end
	end
end</string>
          </Properties>
        </Item>
      </Item>
      <Item class="Script" referent="57">
        <Properties>
          <string name="Name">Movement</string>
          <string name="Source">math.randomseed(tick())
--Services
local PFS = game:GetService("PathfindingService")
local path = PFS:CreatePath()
local pathinprogress = false

--update wait()
local wait = task.wait

--TODO: Add states that the chao can use to show the correct animation.
--[[
	States
	Walk --> Chao is walking around.
	Normal --> The Idle State.
	Thinking --> The State that comes right before the walk state. The chao is deciding what to do.
	Sleeping --> The chao is recharging it energy.
]]

--Makes chao move
function followPath(object, goal)
	--Calculate the path
	local waypoints
	local hum = object.Parent.Humanoid
	local humroot = object.Parent.HumanoidRootPart
	local success, failed = pcall(function()
		path:ComputeAsync(object.Position, goal)
	end)
	--Make sure the calculations actually work.
	if success and path.Status == Enum.PathStatus.Success then
		waypoints = path:GetWaypoints()
		for i, waypoint in pairs(waypoints) do
			--Make sure no one picked up the chao since the last waypoint
			if script.Parent.Held.Value == false then
				if waypoint.Action == Enum.PathWaypointAction.Jump then
					wait(1) --make the chao pause before jumping
					hum:ChangeState(Enum.HumanoidStateType.Jumping)
				end
				--Move to the waypoint
				humroot:MoveTo(waypoint.Position)
				--wait until the walk is finished
				humroot.MoveToFinished:Wait(1)
			else
				break
			end
		end
		pathinprogress = false
	else
		warn("Unable to compute path. "..tostring(failed))
	end
end

--Make sure the boundaries are not in the path
local function generateMovement()
	--Do some math to make sure we're not too close to walls
	local startPos = script.Parent.HumanoidRootPart.Position
	local walls = workspace.Walls
	local outsideForce = false
	local randomVector
	for i, v in pairs(walls:GetChildren()) do
		local magnitude = (startPos.Magnitude - v.Position.Magnitude)
		if magnitude &lt;= 100 then
			--return them to the center
			outsideForce = true
			randomVector = Vector3.new(0,0,0) --where the origin will be
		end
	end
	if outsideForce == false then
		--Move around 100 studs
		randomVector = Vector3.new(startPos.X+math.random(-100,100),startPos.Y,startPos.Z+math.random(-100,100)) --add
	end
	followPath(script.Parent.HumanoidRootPart, randomVector)
end

--Delay 5 seconds before running
wait(5)

--Run every second.
while wait(1) do
	if script.Parent.Parent == workspace then
		if script.Parent.Held.Value == false then
			if pathinprogress == false then
				generateMovement()
			end
		end
	end
end</string>
        </Properties>
      </Item>
      <Item class="Script" referent="58">
        <Properties>
          <string name="Name">Sounds</string>
          <string name="Source">--[[
    Sounds
    Handles chao's sounds
]]</string>
        </Properties>
      </Item>
      <Item class="Script" referent="59">
        <Properties>
          <string name="Name">States</string>
          <string name="Source">--[[
    States
    Handles animating the chao
]]

--Collect the chao and the HumanoidObject
local chao = script.Parent
local hum = script.Parent.Humanoid
--Get the runtime.
local RS = game:GetService("RunService")
--ChaoState
local ChaoState = "none"

--Runs on every frame.
RS.Heartbeat:Connect(function()
    local currentlyPlaying = nil
    --Create an Animation Object
    local anim = Instance.new("Animation")
    --Define the hum's State
    local humState = hum:GetState()
    --Check the humState
    if humState == Enum.HumanoidStateType.Running then
        if ChaoState == "Swimming" then
            if currentlyPlaying ~= "Swimming" then
                currentlyPlaying =  "Swimming"
                if anim.IsPlaying == true then
                    anim:Stop()
                end
                --TODO: Show different anims depending on chaos skill
                anim.Id = "rbxassetid://" --Make anim
                hum.Animator:LoadAnimation(anim)
                anim:Play()
            end
        elseif ChaoState == "none" then
            if currentlyPlaying ~= "Running" then
                currentlyPlaying =  "Running"
                if anim.IsPlaying == true then
                    anim:Stop()
                end
                --TODO: Show different anims depending on chaos skill
                anim.Id = "rbxassetid://" --Make anim
                hum.Animator:LoadAnimation(anim)
                anim:Play()
            end
        end
    elseif humState == Enum.HumanoidStateType.Freefall then
        if currentlyPlaying ~= "Flying" then
            --TODO: Check if they can actually fly
            currentlyPlaying = "Flying"
            if anim.IsPlaying == true then
                anim:Stop()
            end
            anim.Id = "rbxassetid://" --Make anim
            hum.Animator:LoadAnimation(anim)
            anim:Play()
        end
    else
        if currentlyPlaying ~= "Idle" then
            currentlyPlaying =  "Idle"
            if anim.IsPlaying == true then
                anim:Stop()
            end
            anim.Id = "rbxassetid://" --Make anim
            hum.Animator:LoadAnimation(anim)
            anim:Play()
        end
    end
end)

--Change the chao's state to swimming if they're touching a part named "Water"
script.Parent.Touched:Connect(function(hit)
    if hit.Name == "Water" then
        ChaoState = "Swimming"
    else
        ChaoState = "none"
    end
end)</string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="60">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Script" referent="61">
      <Properties>
        <string name="Name">Age</string>
        <string name="Source">--[[
    Age
    Handle Chao Aging
]]

--Define the player and the chao's Data
local chaoData = script.Parent.Name
local chaoModule = require(game.ReplicatedStorage.PublicDependancies.ChaoModule)

game.Players.PlayerAdded:Connect(function(player)
    repeat
        wait()
    until script.Parent == workspace
    while wait() do
        if player.Leaderstats:FindFirstChild(chaoData) then
            if not workspace.currentGarden.Value == "Lobby" and player.Leaderstats[chaoData].canAge == true then
                player.Leaderstats[chaoData].Age.Value += 0.00055
                if player.Leaderstats[chaoData].Age.Value >= 1 and script.Parent.Held == false and player.Leaderstats[chaoData].Ability == "Child" then
                    -- chaoModule
                    chaoModule:Evo(player.Leaderstats[chaoData],script.Parent,player)
                elseif player.Leaderstats[chaoData].Age.Value >= 4 and script.Parent.Held == false then
                    if player.Leaderstats[chaoData].Happiness.Value >= 50 then
                        --Pink Cocoon (Rebirth)
                        chaoModule:Rebirth(player.Leaderstats[chaoData],script.Parent,player)
                    else
                        --White cocoon (death)
                        chaoModule:RemoveChao(player.Leaderstats[chaoData],script.Parent,player)
                    end
                end
            end
        end
    end
end)</string>
      </Properties>
    </Item>
    <Item class="Script" referent="62">
      <Properties>
        <string name="Name">ClassroomServerHandle</string>
        <string name="Source">local classroomService = require(game.ReplicatedStorage.PublicDependancies.Classroom)

game.Players.PlayersAdded:Connect(function(player)
    if player then
        local lastLogTime = player.Leaderstats.lastLogTime
        
    end
end)</string>
      </Properties>
    </Item>
    <Item class="Script" referent="63">
      <Properties>
        <string name="Name">ContextMenuController</string>
        <string name="Source">--[[
	ContextMenuController
	Controls Context Menus created with UIService.
]]

local PromptService = game:GetService("ProximityPromptService")
local UIService = require(game.ReplicatedStorage.PublicDependancies.UIService)
local chaoModule = require(game.ReplicatedStorage.PublicDependancies.ChaoModule)

PromptService.PromptTriggered:Connect(function(prompt, player)
	if prompt and player then
		local promptStatus = UIService:GetContextMenuProperty(prompt,"Context")
		if prompt.Name == "Pet" then
			local chao = prompt.Parent
			chao.Held.Value = true
			--Play petting anim and sound
			wait(1)
			chaoModule.changeData("Happiness",1,player.ChaoData)
			chaoModule.changeData("AbilityDirection",0.33,player.ChaoData)
			chao.Held.Value = false
		end
		if prompt.Name == "Pickup" then
			if promptStatus == "Pick" then
				prompt.Parent.Held.Value = true
				prompt.Parent.Parent = player.Character
				--Load Carry Animation
				--Weld to the player
				local humroot = player.Character:FindFirstChild("HumanoidRootPart")
				local chao = prompt.Parent
				chao.CFrame = humroot.CFrame * CFrame.new(0,0,-1)
				local weld = Instance.new("WeldConstraint")
				weld.Part0 = humroot
				weld.Part1 = chao
				weld.Name = "Weld"
				weld.Parent = chao
			end
			if promptStatus == "Drop" then
				local chao = prompt.Parent
				if chao:FindFirstChild("Weld") then
					chao.Held.Value = false
					chao.Weld:Destroy()
					chao.Parent = workspace
				end
			end
			if promptStatus == "Throw" then
				local chao = prompt.Parent
				if chao:FindFirstChild("Weld") then
					chao.Held.Value = false
					local lookVector = chao.Parent.HumanoidRootPart.CFrame.LookVector
					chao.Weld:Destroy()
					chao.Parent = workspace
					chao.Velocity = chao.CFrame:VectorToWorldSpace(Vector3.new(0, 0, -300))
					chaoModule.changeData("Happiness",-1,player.ChaoData)
					chaoModule.changeData("AbilityDirection",-0.03,player.ChaoData)
					if chao.Name == "Egg" then
						chaoModule.newChao()
						chaoModule.Hatch(chao)
					end
				end
			end
		end
		if prompt.Name == "ChaoDrive" then
			local promptStatus = UIService:GetContextMenuProperty(prompt,"Context")
			if promptStatus == "Pickup" then
				prompt.Parent.Held.Value = true
				prompt.Parent.Parent = player.Character
				local humroot = player.Character:FindFirstChild("HumanoidRootPart")
				local chao = prompt.Parent
				chao.CFrame = humroot.CFrame * CFrame.new(0,0,-1)
				local weld = Instance.new("WeldConstraint")
				weld.Part0 = humroot
				weld.Part1 = chao
				weld.Name = "Weld"
				weld.Parent = chao
			end
			if promptStatus == "Drop" then
				local chao = prompt.Parent
				if chao:FindFirstChild("Weld") then
					chao.Held.Value = false
					chao.Weld:Destroy()
					chao.Parent = workspace
				end
			end
		end
	end
end)</string>
      </Properties>
    </Item>
    <Item class="Script" referent="64">
      <Properties>
        <string name="Name">Datastore</string>
        <string name="Source">--TODO: Improve this
local module = require(game.ReplicatedStorage.PublicDependancies.ChaoModule)-->Datastore uses folder from ChaoModule
local Datastore = game:GetService("DataStoreService")
local saveData = Datastore:GetDataStore("Sonic Earth Chao Garden")

game.Players.PlayerAdded:Connect(function(player)
	if player and module then
		wait(2)
		local folder = game.ReplicatedStorage.Folder:Clone()
		folder.Name = "ChaoData"
		folder.Parent = player
		--load data
		local data

		local success, errormessage = pcall(function(player)
			data = saveData:GetAsync("User_"..player.UserId) --finish this
		end)

		if success then
			--set values
			folder.Ability.Value = data.Ability
			folder.Age.Value = data.Age
			folder.Attribute.Value = data.Attribute
			folder.ChaoName.Value = data.ChaoName
			folder.Class.Value = data.ChaoClass
			folder.Condition.Value = data.Condition
			folder.FlyLevel.Value = data.FlyLevel
			folder.FlyRank.Value = data.FlyRank
			folder.FlyXP.Value = data.FlyXP
			folder.Happiness.Value = data.Happiness
			folder.Happiness.Value = data.Hunger
			folder.Hatched.Value = data.Hatched
			folder.Personality.Value = data.Personality
			folder.PowerLevel.Value = data.PowerLevel
			folder.PowerRank.Value = data.PowerRank
			folder.PowerXP.Value = data.PowerXP
			folder.RunLevel.Value = data.RunLevel
			folder.RunRank.Value = data.RunRank
			folder.RunXP.Value = data.RunXP
			folder.StaminaLevel.Value = data.StaminaLevel
			folder.StaminaRank.Value = data.StaminaRank
			folder.StaminaXP.Value = data.StaminaXP
			folder.SwimLevel.Value = data.SwimLevel
			folder.SwimXP.Value = data.SwimXP
			folder.spawn.Value = data.spawm
		end
	else
		warn("An error occured while loading data.")
	end
end)

--game.Players.PlayerRemoving:Connect(function(player)
--	local data = {}
--	for i,v in pairs(player.ChaoData:GetChildren()) do
--		table.insert(data, v.Value)
--	end
--	local success, errormessage = pcall(function()
--		saveData:SetAsync("User_"..player.UserId, data)
--	end)
--	if success then
--		print("Save Data Saved Sucessfully!")
--	else
--		warn("An Error Occured while saving save data to server")
--		warn(errormessage)
--	end
--end)</string>
      </Properties>
    </Item>
    <Item class="Script" referent="65">
      <Properties>
        <string name="Name">EatChaoDrive</string>
        <string name="Source">--[[
	EatChaoDrive
	Handles chao eating or absords things
]]
local remote = game.ReplicatedStorage.Remotes.Eat
local chaoModule = require(game.ReplicatedStorage.PublicDependancies.ChaoModule)

remote.OnServerEvent:Connect(function(stat,value,chaoData,objClass,obj)
	print("fired!")
	print(objClass)
	if objClass == "Drive" then
		chaoModule.changeStat(stat,value,chaoData)
	end
	if objClass == "Fruit" then
		chaoModule.changeStat(stat,value,chaoData)
		--Chao are happier when feed
		chaoModule.changeData("Hunger",-value,ChaoData)
		chaoModule.changeData("Happiness",1,ChaoData)
		--Since Shadow isn't in the game, we'll just always change it to positive. So they'll need to buy lots of dark fruit or mean to get a dark chao
		chaoModule.changeData("AbilityDirection",0.33,ChaoData)
	end
	if objClass == "Wisp" then
		chaoModule.changeStat(stat,value,chaoData)
	end
	--Play Anim and Sound
	wait(0.2)
	obj:Destroy()
end)</string>
      </Properties>
    </Item>
    <Item class="Script" referent="66">
      <Properties>
        <string name="Name">LocalTeleportService</string>
        <string name="Source">--[[
	LocalTeleportService
	Handles when people open doors
]]

local debound = false
local wait = task.wait
local garden = workspace.currentGarden

function getDoors(doorName)
	local found = false
	for i,v in pairs(workspace.Doors.Gate:GetChildren()) do
		local temp = v:GetAttribute("DoorName")
		if temp == doorName then
			found = true
			return v.Position
		end
	end
	if found == false then
		return false
	end
end

while wait() do
	for i,v in pairs(workspace.Doors:GetChildren()) do
		if debound == false then
			if v:IsA("Part") then
				debound = true
				v.Touched:Connect(function(hit)
					if hit.Parent:FindFirstChild("Humanoid") then
						local isReturn = v:GetAttribute("isReturn")
						local doorName = v:GetAttribute("DoorName")
						if doorName then
							local goal = getDoors(doorName)
							if goal then
								hit.Parent.HumanoidRootPart.Position = goal
								garden.Value = doorName
							end
						end
					end
				end)
				debound = false
			end
		end
	end
end



--function getDoors(doorName)
--	for l,z in pairs(workspace.Doors.Gate:GetChildren()) do
--		local temp = z:GetAttribute("DoorName")
--		if temp == doorName then
--			return z.Position
--			print("Found it!")
--		end
--	end
--end</string>
      </Properties>
    </Item>
    <Item class="Script" referent="67">
      <Properties>
        <string name="Name">Main</string>
        <string name="Source">-- local chaoModule = require(game.ReplicatedStorage.PublicDependancies.ChaoModule)

-- game.Players.PlayerAdded:Connect(function(plr)
-- 	if plr then
-- 		wait(1)
-- 		if plr:FindFirstChild("Leaderstats")
-- 	end
-- end)</string>
      </Properties>
    </Item>
    <Item class="Script" referent="68">
      <Properties>
        <string name="Name">NeoDatastore</string>
        <string name="Source">--[[
	NeoDatastore
	The new script responsible for saving.
]]

local Datastore = game:GetService("DataStoreService")
local saveData = Datastore:GetDataStore("Sonic Earth Chao Garden Alpha")
--Instead of generating a new folder every time with the old Main script simply generate a new folder only if we need to.
local module = require(game.ReplicatedStorage.PublicDependancies.ChaoModule)

game.Players.PlayerAdded:Connect(function(player)
	workspace.currentGarden.Value = "Lobby"
	if player and module then
		--Create a chaoData folder
		local main = Instance.new("Folder")
		main.Name = "Leaderstats"
		main.Parent = player
		--Create the folder for the data
		local folder = game.ReplicatedStorage.Folder:Clone()
		--Don't change the name. We'll be naming it to the chao's name
		folder.Parent = main
		--load data
		local data = saveData:GetAsync("User_"..player.UserId)
		
		if data then
			for i,v in pairs(folder:GetChildren()) do
				v.Value = data[v]
			end
			folder.Name = data.ChaoName
		else
			print("Creating new data!")
			module.newChao()
			print("SaveData Ready")
		end
	end
end)

function createSaveTable(player)
	local saveTable = {}
	for i,v in pairs(player.Main:GetDescendants()) do
		if not v:IsA("Folder") then
			saveTable[v.Name] = v.Value
		end
	end
	return saveTable
end

game.Players.PlayerRemoving:Connect(function(player)
	local data = createSaveTable(player)
	local success, errormessage = pcall(function()
		saveData:SetAsync("User_"..player.UserId, data)
	end)
	if success then
		print("Save Data Saved Sucessfully!")
	else
		warn("An Error Occured while saving save data to server")
		warn(errormessage)
	end
end)</string>
      </Properties>
    </Item>
    <Item class="Script" referent="69">
      <Properties>
        <string name="Name">WorldHandle</string>
        <string name="Source">--[[
	WorldHandle
	Handles Changeing the garden
]]

local theme = workspace.Theme --No need for AudioAttempt for now.
local garden = workspace.currentGarden
local chaoWorld = "rbxassetid://397169354" --Temporary
local neutGarden = "rbxassetid://186088305"
local Kinder = ""
local loading = ""

wait(4)
print("Ready!")
garden.Value = "none"

garden.Changed:Connect(function()
	if garden.Value == "Garden" then
		theme.SoundId = neutGarden
	elseif garden.Value == "Kindergarden" then
		theme.SoundId = Kinder
	else
		theme.SoundId = chaoWorld
	end
end)</string>
      </Properties>
    </Item>
  </Item>
  <Item class="StarterGui" referent="70">
    <Properties>
      <string name="Name">StarterGui</string>
    </Properties>
    <Item class="ScreenGui" referent="71">
      <Properties>
        <string name="Name">Classroom</string>
      </Properties>
      <Item class="LocalScript" referent="72">
        <Properties>
          <string name="Name">DoctorUI</string>
          <string name="Source"><![CDATA[--[[
	DoctorUI
	Handles the Doctor Office.
]]

local chaoService = require(game.ReplicatedStorage.PublicDependancies.ChaoModule)
local UIService = require(game.ReplicatedStorage.PublicDependancies.UIService)
local UIS = game:GetService("UserInputService")

local on = true

normalReply = {
	"Oh no! Your chao is perfectly healthy.";
	"Your chao seems fine.";
	"Nothing is wrong with your chao.";
	"Your chao is very healthy!";
	"Your chao isn't sick."
}

images = {
	"http://www.roblox.com/asset/?id=8888502969",
	"http://www.roblox.com/asset/?id=8888496721",
	"http://www.roblox.com/asset/?id=7921523503",
	"http://www.roblox.com/asset/?id=8888481815",
	"http://www.roblox.com/asset/?id=8888475280",
	"http://www.roblox.com/asset/?id=8888468390"
}

function write()
	local rng = math.random(#normalReply)
	local text = normalReply[rng]
	for i = 1, #text do
		script.Parent.TextLabel.Text = string.sub(text, 1, i)
		wait(0.03)
	end
	on = false
end

function fillData(chaoData)
	--Uses the chaoService:GetStat() to set the data of the pages. Also UIService:CreateChaoViewPort() for the first page with the visial of your chao. 
	--Basic Frame
	local topFrame = script.Parent.Frame
	local basic = topFrame.Basic
	local chao = game.Players.LocalPlayer.Character:FindFirstChild("Held",true)
	if chao then
		UIService:CreateChaoViewPort(chao,basic.Viewport,true)
		chao = workspace.TempChao
		for i,v in pairs(script.Parent.Frame.Basic:GetChildren()) do
			if v:IsA("TextLabel") then
				if chaoService:GetStats(chao.Id.Value,game.Players.LocalPlayer,v.Name) then
					v.Text = chaoService:GetStats(chao.Id.Value,game.Players.LocalPlayer,v.Name)
				end
			end
			if v:IsA("ImageLabel") then
				v.Image = images[chaoService:GetStats(chao.Id.Value,game.Players.LocalPlayer,v.Name)]
			end
		end
	end
end

while wait() do
	if on == true then
		for i,v in pairs(script.Parent.Start:GetChildren()) do
			if v:IsA("TextButton") then
				v.MouseEnter:Connect(function()
					v.UIStroke.Thickness = 5
				end)
				v.MouseLeave:Connect(function()
					v.UIStroke.Thickness = 0
				end)
				v.MouseButton1Click:Connect(function()
					if v.Name == "Look" then
						on = false
						write()
					elseif v.Name == "Charts" then
						local chao = game.Players.LocalPlayer.Character:FindFirstChild("Held",true)
						script.Parent.Start.Visible = false
						script.Parent.Frame.Visible = true
						fillData(chao.Name)
					end
				end)
			end
		end
	end
end
]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="LocalScript" referent="73">
      <Properties>
        <string name="Name">UI</string>
        <string name="Source">--[[
	UI
	Handles UI
]]

local UIService = require(game.ReplicatedStorage.PublicDependancies.UIService)

local ui = script.Parent.ScreenGui.Frame.GardenLogo
local garden = workspace.currentGarden

game.Players.PlayerAdded:Connect(function()
	print("New Player!")
	repeat wait(1) until game.Players.LocalPlayer.CharacterAppearanceLoaded == true
	print("Ready!")
	ui.Visible = true
	ui.Image = "rbxassetid://8596805320"
	wait(3)
	ui.Visible = false
end)

garden.Changed:Connect(function()
	print(garden.Value)
	if garden.Value ~= "loading" then
		ui.Visible = true
		if garden.Value == "Garden" then
			ui.Image = "rbxassetid://8596788034"
		elseif garden.Value == "Kindergarden" then
			ui.Image = "rbxassetid://8596801475"
		else
			ui.Image = "rbxassetid://8596805320"
		end
		wait(3)
		ui.Visible = false
	else
		script.Parent.ScreenGui.Fade.Visible = true
		wait(1.5)
		script.Parent.ScreenGui.Fade.Visible = false
	end
end)

local plr = game.Players.LocalPlayer

workspace.kinder.Doctor.Touched:Connect(function(hit)
	if hit.Parent:FindFirstChild("Humanoid") then
		local chaoExistence = plr.Character:FindFirstChild("Held", true)
		if chaoExistence then
			script.Parent.Classroom.Start.Visible = true
			local chao = chaoExistence.Parent
			UIService:CreateViewPort(chao,script.Parent.Basic,true)
		end
	end
end)</string>
      </Properties>
    </Item>
  </Item>
  <Item class="StarterPlayer" referent="74">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterCharacterScripts" referent="75">
      <Properties>
        <string name="Name">StarterCharacterScripts</string>
      </Properties>
      <Item class="LocalScript" referent="76">
        <Properties>
          <string name="Name">Animate</string>
          <string name="Source"><![CDATA[local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local animateScriptEmoteHookFlagExists, animateScriptEmoteHookFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserAnimateScriptEmoteHook")
end)
local FFlagAnimateScriptEmoteHook = animateScriptEmoteHookFlagExists and animateScriptEmoteHookFlagEnabled

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
		{ id = "http://www.roblox.com/asset/?id=8311784209", weight = 1 },
		{ id = "http://www.roblox.com/asset/?id=8311784209", weight = 1 },
		{ id = "http://www.roblox.com/asset/?id=8311784209", weight = 9 }
	},
	walk = 	{ 	
		{ id = "http://www.roblox.com/asset/?id=8311691667", weight = 10 } 
	}, 
	run = 	{
		{ id = "http://www.roblox.com/asset/?id=8311757370", weight = 10 } 
	}, 
	swim = 	{
		{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
	}, 
	swimidle = 	{
		{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
	}, 
	jump = 	{
		{ id = "http://www.roblox.com/asset/?id=8311751167", weight = 10 } 
	}, 
	fall = 	{
		{ id = "http://www.roblox.com/asset/?id=8311789859", weight = 10 } 
	}, 
	climb = {
		{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
	}, 
	sit = 	{
		{ id = "http://www.roblox.com/asset/?id=5954894701", weight = 10 } 
	},	
	toolnone = {
		{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
	},
	toolslash = {
		{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
	},
	toollunge = {
		{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
	},
	wave = {
		{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
	},
	point = {
		{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
	},
	dance = {
		{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
		{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
		{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
	},
	dance2 = {
		{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
		{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
		{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
	},
	dance3 = {
		{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
		{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
		{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
	},
	laugh = {
		{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
	},
	cheer = {
		{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
	},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end

	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end

	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))

		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end

	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end

	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	if FFlagAnimateScriptEmoteHook and currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end

	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end

	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			return 1
		end

		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return 1
end

local smallButNotZero = 0.0001
function setRunSpeed(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale

	if runSpeed ~= currentAnimSpeed then
		if runSpeed < 7.33 then
			currentAnimTrack:AdjustWeight(8.0)		
			runAnimTrack:AdjustWeight(smallButNotZero)
		elseif runSpeed < 5.66 then
			local weight = ((runSpeed - 5.33) / 5.33)
			currentAnimTrack:AdjustWeight(8.0 - weight + smallButNotZero)
			runAnimTrack:AdjustWeight(weight + smallButNotZero)
		else
			currentAnimTrack:AdjustWeight(smallButNotZero)
			runAnimTrack:AdjustWeight(8.0)
		end
		currentAnimSpeed = runSpeed
		runAnimTrack:AdjustSpeed(runSpeed)
		currentAnimTrack:AdjustSpeed(runSpeed)
	end	
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
		setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end

			if FFlagAnimateScriptEmoteHook and currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end

				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end

			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then

		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0

		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core

		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)

		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		

			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	if (toolAnimInstance ~= anim) then

		if (toolAnimTrack ~= nil) then
			toolAnimTrack:Stop()
			toolAnimTrack:Destroy()
			transitionTime = 0
		end

		-- load it to the humanoid; get AnimationTrack
		toolAnimTrack = humanoid:LoadAnimation(anim)
		if priority then
			toolAnimTrack.Priority = priority
		end

		-- play the animation
		toolAnimTrack:Play(transitionTime)
		toolAnimName = animName
		toolAnimInstance = anim

		currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
	end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)	
	if speed > 0.75 then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end


function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
	local deltaTime = currentTime - lastTick
	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

	if (jumpAnimTime > 0) then
		jumpAnimTime = jumpAnimTime - deltaTime
	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = wait(0.1)
	stepAnimate(currentGameTime)
end

]]></string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="77">
        <Properties>
          <string name="Name">Feed</string>
          <string name="Source">--[[
	Feed
	Checks when the player gives a Chao a drive
]]

--Prevents the same even from firing forever.
local debound = false
--The remote event that the chao drive handler uses.
local remote = game.ReplicatedStorage.Remotes.Eat
--Get ClassService
local classService = require(game.ReplicatedStorage.PublicDependancies.ClassService)
math.randomseed(tick())
local wait = task.wait

--run the function forever without crashing.
while wait() do
	for i,v in pairs(workspace:GetChildren()) do
		local myClass = classService:GetItemsClass(v.ChaoClass)
		if myClass == "Drive" then
			if debound == false then
				debound = true
				if v.Name == "FlyDrive" then
					v.Touched:Connect(function(hit)
						if hit:FindFirstChild("Held") then
							remote:FireServer("Fly",math.random(3,6),v.Name,"Drive",v)
						end
					end)
				end
				if v.Name == "PowerDrive" then
					v.Touched:Connect(function(hit)
						if hit.Parent:FindFirstChild("Held") then
							remote:FireServer("Power",math.random(3,6),v.Name,"Drive",v)
						end
					end)
				end
				if v.Name == "RunDrive" then
					v.Touched:Connect(function(hit)
						if hit.Parent:FindFirstChild("Held") then
							remote:FireServer("Run",math.random(3,6),v.Name,"Drive",v)
						end
					end)
				end
				if v.Name == "SwimDrive" then
					v.Touched:Connect(function(hit)
						if hit.Parent:FindFirstChild("Held") then
							remote:FireServer("Swim",math.random(3,6),v.Name,"Drive",v)
						end
					end)
				end
				debound = false
			end
		end
		if myClass == "Fruit" then
			if debound == false then
				debound = true
				if v.Name == "SkillsFruit" then
					v.Touched:Connect(function(hit)
						if hit.Parent:FindFirstChild("Held") then
							remote:FireServer("Skill",math.random(3,10),v.Name,"Fruit",v)
						end
					end)
				end
			end
		end
	end
end</string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="78">
        <Properties>
          <string name="Name">Shake</string>
          <string name="Source">--[[
	Shake
	Allows you to shake eggs
]]

local UIS = game:GetService("UserInputService")

local shakeBind = Enum.KeyCode.X
local debounce = false


UIS.InputBegan:Connect(function(input)
	if input.KeyCode == shakeBind then
		if script.Parent:FindFirstChild("Egg") and debounce == false then
			debounce = true
			--Play Shake Tween or smth
			script.Parent.Egg.HatchTime -= 20
			print("Shoke")
			wait(2)
			debounce = false
		end
	end
end)</string>
        </Properties>
      </Item>
    </Item>
  </Item>
</roblox>